ðŸ“’ HashMap in Java 

1. Introduction
âž¤ A HashMap is a part of the Java Collections Framework.
âž¤ It implements the Map interface and stores data in key-value pairs.
âž¤ Keys â†’ Must be unique.
âž¤ Values â†’ Can be duplicated.
âž¤ Null Support â†’ One null key allowed, multiple null values allowed.

2. Hierarchy
Map (Interface)
    |
    v
HashMap (Class)

3. Features of HashMap
âž¤ Unordered: Does not maintain insertion order.
âž¤ Unique Keys: Duplicate keys overwrite the previous value.
âž¤ Null Values: One null key, multiple null values allowed.

âž¤ Time Complexity:
1. Average case â†’ O(1) for put(), get(), remove().
2. Worst case â†’ O(n) (when hash collisions occur heavily).
âž¤ Non-synchronized: Not thread-safe (use Collections.synchronizedMap() or ConcurrentHashMap for thread safety).


5. Example Code
package p1;

import java.util.HashMap;
import java.util.Map;

public class HashMapIntro {
    public static void main(String[] args) {
        Map<String, Integer> mp = new HashMap<>();

        // Adding entries
        mp.put("234567", 3454);
        mp.put("345654", 4544); // Numbers with leading 0 are octal â†’ avoid for strings
        System.out.println(mp); // {234567=3454, 345654=4544}

        // Removing entry
        int val = mp.remove("234567");
        System.out.println(val); // 3454

        // Printing after removal
        System.out.println(mp); // {345654=4544}
    }
}

6. Common Methods
| Method                        | Description                      |
| ----------------------------- | -------------------------------- |
| `put(K key, V value)`         | Adds or updates a key-value pair |
| `get(Object key)`             | Returns value for the given key  |
| `remove(Object key)`          | Removes entry by key             |
| `containsKey(Object key)`     | Checks if key exists             |
| `containsValue(Object value)` | Checks if value exists           |
| `keySet()`                    | Returns set of keys              |
| `values()`                    | Returns collection of values     |
| `entrySet()`                  | Returns set of key-value entries |

7. Iterating Through HashMap
ðŸ”· Using for-each on entrySet()
for (Map.Entry<String, Integer> entry : mp.entrySet()) {
    System.out.println(entry.getKey() + " â†’ " + entry.getValue());
}

ðŸ”· Using keySet()
for (String key : mp.keySet()) {
    System.out.println(key + " â†’ " + mp.get(key));
}

ðŸ”· Using Iterator
Iterator<Map.Entry<String, Integer>> itr = mp.entrySet().iterator();
while (itr.hasNext()) {
    Map.Entry<String, Integer> entry = itr.next();
    System.out.println(entry.getKey() + " â†’ " + entry.getValue());
}

8. Real-World Use Cases in Projects
âž¤ Database Caching â†’ Store query results temporarily with query as key.
âž¤ User Session Management â†’ Map session IDs to user objects.
âž¤ Counting Occurrences â†’ Word frequency counters in text processing.
âž¤ Configuration Settings â†’ Map setting names to their values.

9. Points to Remember 
âž¤ Order Not Maintained â†’ Use LinkedHashMap if you want insertion order.
âž¤ Thread Safety â†’ Use ConcurrentHashMap in multi-threaded environments.
âž¤ Fail-Fast â†’ Iterators throw ConcurrentModificationException if map is modified during iteration (except via iteratorâ€™s remove()).
âž¤ Performance Tuning â†’ You can set initial capacity & load factor in constructor for better performance.

ðŸ“’ Internal Working of HashMap in Java
1. Internal Data Structure
âž¤ HashMap internally uses a Hash Table to store data.
âž¤ A hash table is basically an array of buckets.
âž¤ Bucket â†’ Each position in the array can store multiple entries if collisions occur (via linked list or tree).
âž¤ In Java 8+, if a single bucket gets too many elements (default threshold: 8), it is converted from LinkedList to a balanced Red-Black Tree to improve performance from O(n) to O(log n).

2. Initial Capacity
Default initial capacity = 16 buckets (array length).

You can set capacity in the constructor:
Map<String, String> mp = new HashMap<>(32);

This means the hash table will start with 32 buckets.

3. Load Factor
Load factor = 0.75 (default).
Formula: Threshold = Capacity Ã— Load Factor

Example:
Initial capacity = 16
Threshold = 16 Ã— 0.75 = 12

When the 13th entry is inserted, capacity doubles to 32.
New threshold = 32 Ã— 0.75 = 24.

Why Load Factor Exists?
âž¤ To balance time complexity and memory usage.
Higher load factor â†’ fewer resizes (less memory usage, but more collisions).
âž¤ Lower load factor â†’ more resizes (faster lookups, but higher memory usage).

4. hashCode() in HashMap
âž¤ Every Java object has a hashCode() method (from Object class).
âž¤ hashCode() returns an integer representing the objectâ€™s memory-like identity (but not actual memory address).

âž¤ HashMap uses it to determine bucket index:
index = (hashCode(key) & (capacity - 1))
& (capacity - 1) works because capacity is always a power of two â†’ faster than % capacity.

5. Collision in HashMap
âž¤ Collision = Two different keys generate the same bucket index.

How itâ€™s handled:
âž¤ Before Java 8 â†’ Collision handled by LinkedList chaining in the bucket.
âž¤ Java 8 and later:
1. If bucket size < 8 â†’ stored as LinkedList.
2. If bucket size â‰¥ 8 â†’ converted to Red-Black Tree for faster lookups.
3. If bucket size reduces < 6 â†’ Tree is converted back to LinkedList.

Example:
Map<Integer, String> map = new HashMap<>();
map.put(1, "A");
map.put(17, "B"); // 1 and 17 might fall into the same bucket (collision)

7. Step-by-Step Flow of put()
âž¤ Check if table is empty â†’ initialize to default capacity (16).
âž¤ Compute hash from hashCode() of the key.
âž¤ Calculate index = (hash & (capacity - 1)).
âž¤ If no entry exists in that bucket â†’ insert new node.

âž¤ If entry exists:
1. If key matches â†’ update value.
2. If key different but same index â†’ collision â†’ add to LinkedList or Tree.
âž¤ If size exceeds threshold â†’ rehash (double capacity).

8. Step-by-Step Flow of get()
âž¤ Compute hash from hashCode() of key.
âž¤ Calculate index.
âž¤ Search bucket:
1. If LinkedList â†’ iterate and match key using equals().
2. If Tree â†’ binary search.
âž¤ Return value if found, else return null

Drawbacks / Limitations of HashMap
1. No Order Guarantee
âž¤ HashMap does not maintain insertion order or any sorted order of keys.
âž¤ Iteration order can change when new entries are added (especially after rehashing).
âž¤ If order is important, use LinkedHashMap (insertion order) or TreeMap (sorted order).

2. Not Thread-Safe
âž¤ HashMap is not synchronized â†’ multiple threads modifying it at the same time can cause data corruption or infinite loops.
âž¤ For thread safety:
1. Use Collections.synchronizedMap() wrapper.
2. Or use ConcurrentHashMap.

3. High Memory Usage
âž¤ HashMap needs extra memory for buckets, linked lists, and tree nodes.
âž¤ More collisions = more memory usage.
âž¤ Large load factor â†’ more collisions â†’ more chaining â†’ higher memory consumption.

4. Performance Degrades with Poor hashCode()
âž¤ If hashCode() is poorly implemented, many keys may end up in the same bucket.
âž¤ This increases collision frequency â†’ performance drops from O(1) to O(n).
âž¤ In Java 8+, this degrades to O(log n) if treeified, but still slower than constant time.

5. One Null Key Limit
âž¤ Can only have one null key.
âž¤ Multiple null values are allowed, but only a single null key.
âž¤ Sometimes inconvenient if multiple null-like placeholders are needed.

6. Rehashing Cost
When the threshold is exceeded, rehashing happens:
1. Doubles capacity
2. Redistributes all existing keys
3. Can be CPU intensive for large maps.

7. Fail-Fast Behavior
âž¤ Iterators of HashMap are fail-fast:
1. If the map is structurally modified during iteration (except via the iteratorâ€™s own remove method), it throws ConcurrentModificationException.
âž¤ This makes multi-threaded iteration tricky without external synchronization.

8. Large Data = Cache Unfriendly
âž¤ Since entries are spread across buckets and nodes, large HashMaps can be less cache-efficient compared to arrays.
âž¤ This can cause slower real-world performance despite good average-case complexity.

