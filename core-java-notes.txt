What is a class?
-> A class in Java is a blueprint or template for creating objects.
-> It defines the data (fields/attributes) and the behavior (methods/functions) that the objects created from the class will have.
-> Class helps us to create objects in Java.

Class Naming Convention
#######################
-> In Java, we use the class keyword to create a class, and the class keyword should be in lowercase. The class name should start with an uppercase letter only.
-> If more than one word is used, then we should use camel casing.

Note: class name cannot start with a number but can begin with $ or underscore(_), but it is not recommended.

Example :
class A {}
-> We define the boundary of a class using curly brackets.
  
Example :
-> Will execute without any error
public class Bank_Account_Number {}// Snake Casing-->Should not use for Java

Note:
1. Do not use specials characters like #,@ % & etc while creating class.
2. $Class name will execute. But never create a class with a special character $.

new keyword:
##############
The new keyword in Java is used to create objects (instances) of a class. 
-> Using the new keyword, we send a request to the class to create an object
-> Once the object is created new keyword will get the object's address and store that in a reference variable.

Syntax to create an object:
-------------------------
ClassName variableName = new ClassName();

Note:
Two types of camel casing:
a. Upper Case Camel Casing: Used for naming class, interface, abstract class, etc
b. Lower Case Camel Casing: Used for creating methods, variables, etc
_______________________________________________________________________ 

Non-static Variable/ Instance Variable /Object Variables
#########################################################
It is a variable declared inside a class, but outside any method, and without the static keyword.
📌 It belongs to:
An instance of the class (not the class itself)
Every object has its copy

1. We should create a non-static variable inside a class outside a method without using the static keyword.
2. Without creating an object, we cannot access non non-static variable.

Example :
public class A {
	int x = 10;
	int y = 20;
  int z;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1.x); // Output :10
		System.out.println(a1.y); // Output :20

    A a2 = new A();
		System.out.println(a2.x); // Output :10
    System.out.println(a2.z); // Output :0 //default value of int is 0
	}
}
3. Every time we create an object non-static variable copy is loaded into that object.
4. A copy of the variable in this object is different. That is, if you change the value of a variable in one object, those changes cannot be seen in another object.
5. It is not mandatory to initialize a non-static variable. Depending on the data type, the default value will be automatically stored in it.

Static variables:
#################
->A static variable is a class-level variable, meaning:
->It belongs to the class, not the object.
->It is shared among all instances of the class.
->Only one copy exists in memory, regardless of how many objects are created.

1. We should create static variables inside a class but outside a method with the static keyword
2. To access a static variable, we will use the following options:
a. ClassName.variableName
b. variableName (Constraints)
c. objectAddress.variableName (Wrong Approach, but will work)

Example:
---------------
public class A {
	static int x=10 ;
	public static void main(String[] args) {
		System.out.println(A.x);// Output :10
		System.out.println(x);// Output :10
    
		//Wrong
		A a1 = new A();
		System.out.println(a1.x);//A.x, but will give the Output:10
                A.x = 30;
		System.out.println(A.x); //Ouput :30 
  }
}

Types of variables in Java
############################

1. Local Variable
######################
a. Local variables should be created inside methods
b. We should use local variables within the created method only
c. Without initialization, if you are using a local variable, you will get an error.
  
Example 1:
---------
public class A {
	static int y=10;
	public static void main(String[] args) {
		int x = 100;
		System.out.println(x);
    		System.out.println(A.y);// Output :10
		A a1 = new A();
         	a1.test();
    		System.out.println(y);//Output: 10
	}
	public void test() {
        int z=100;
	System.out.println(x);//Error because it is not present in this method
        System.out.println(z); //Correct
        System.out.println(A.y);
	}
}

2. Static variable
3. Non-static variable/instance variable

4. Reference Variable
#####################
A reference variable in Java is a variable that stores the memory address (reference) of an object, not the actual object itself.
a. Can hold either an Object address or a null value
b. The datatype of the reference variable is the class 

Example :
----------
In the below example, "a1" is created inside main, and hence it is a local variable. We cannot access that outside the main method

Note: If we do not initialize a static reference variable, then by default null value will be stored in it.
  
public class A {
	static A a4;  //null
	public static void main(String[] args) {
		A a1 = null;
		A a2 = new A();
    		A a3;
    		System.out.println(a3);// Error because "a3" is local variable and not initialized   
	}
  	public void test() {
		System.out.println(a1);//Error
	}
}

🧱 Stack Memory – LIFO (Last In First Out)
###########################################
Stores:
Method calls,
local variables,
and reference variables (not actual objects).

->Memory is automatically managed (pushed and popped as methods are called or returned).
->Operates in LIFO (Last-In, First-Out) order, where the last is the first one to return.
->Faster but limited in size.

🧠 Example:
When a method is called, its variables go on the stack. When it returns, they’re removed.

🗃️ Heap Memory
################
Used to store objects/instance variables.
Every time you do new ClassName(), it creates an object in the heap.
Objects stay in memory until they're no longer referenced.

📍 Note: All reference variables (in the stack) point to objects in the heap.

🗑️ Garbage Collector (GC)
##########################
Java’s automatic memory management tool.
Runs in the background and:
1. Detects objects in the heap no longer referenced
2. Removes them to free memory
3. Helps prevent memory leaks and overflow

📌 You don’t have to manually delete objects — GC handles it.

methods in java
###############
1. void keyword: A void method cannot return any value

Example :
----------
public class C {
	public static void main(String[] args) {
		C c1 = new C();
		int x = c1.test1(); //Error
    		int y= c1.test2();
		System.out.println(y);// Output :100
	}
	public void test1() {
		return 100;//Error
 	 }
	public int test2() {
		return 100;
  	}
}

return without value vs return value in Java
#############################################
The difference between return and return value lies in what you're returning and why.

return without value keyword:
-----------------------------
-> A method has to be void
-> It is optional
-> It will return control to the method calling statement

Note: If we write code after the return keyword, then that code will 100% not run. This error is called an unreachable code error

Example:
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test();
	}
	
	public void test() {
	      System.out.println(100);
	      return;
	      System.out.println(200);
	}
}
Output: unreachable code error

returning "value"
-----------------
-> The method has to be non-void
-> It is mandatory to use a return "value" statement inside a non-void method
-> It will return control and value to the method calling statement

public class C {
	public static void main(String[] args) {}
	public int test1() {}// Error
  	public int test2() {
		return 100; 
		System.out.println(300);// Unreachable code error
	}
}

Method Arguments
##################
-> Using method arguments, we supply values to the method when we call it
-> The method argument is a local variable
-> Arguments inside the method values that you supply to the method should match

Example:
-------
public class C {
	public static void main(String[] args) {
	 C c1 = new C();
    	 C c2 = new C();
	 c1.test1(100);
    	 c2.test2(100,"mike");
	}
	
	public void test1(int x) {
	  System.out.println(x);
	}
  public void test2(int x,String y) {
	  System.out.println(x);
	}
}

Note: When the method argument type is Object, then we can supply any kind of value to it.

public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test('a');
	}
	public void test(Object x) {
	   System.out.println(x);
	}
}

Using Varargs (Variable Arguments)
##################################
Example 2:
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test("mike",100,200,300,400);
	}
	public void test(String y,int... x) { 
		System.out.println(x[0]);// Output :100
		System.out.println(x[1]);// Output :200
		System.out.println(x[2]);// Output :300
		System.out.println(x[3]);// Output :400
		System.out.println(y);// Output :mike
	}
}

Static Methods in Java
######################
A static method belongs to the class, not to instances (objects) of the class.
This means you can call a static method without creating an object of that class.
public class C {
	public static void main(String[] args) {
	    C.test1();// Output :599
    	    int x =  C.test2();
	    System.out.println(x);// Output :100  
	}
	public static void test1() {
		System.out.println(599);
	}
  public static int test2() {
		return 100;
	}
}  

Java Data Types 
################
Java data types are divided into 2 main categories:

🔹 1. Primitive Data Types (8 types)
-------------------------------------
Built-in, fixed-size types that store actual values directly.

🔸 Integer Types (for whole numbers)
--------------------------------------
Type	       Size     	Default Value	      Range
byte	       1 byte	            0	              -128 to 127
short	       2 bytes	   	    0	              -32,768 to 32,767
int	       4 bytes	            0	              -2,147,483,648 to 2,147,483,647
long           8 bytes	            0	              -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807

🔸 Floating Point Types (for decimals)
----------------------------------------
Type	    Size	      Default Value	        Range
float	    4 bytes	      0.0f	              ±3.40282347E+38F (single-precision)
double	    8 bytes	      0.0d	              ±1.79769313486231570E+308 (double-precision)

Find the size of the datatype
#########################
Example:
public class Main {
    public static void main(String[] args) {
        System.out.println("Size of int in bytes: " + Integer.BYTES);//4
        System.out.println("Size of int in bits: " + Integer.SIZE);//32
    }
}

🔸 Other Primitive Types
-----------------------------
Type	    Size	            Default Value	          Description
boolean	    (JVM dependent)	    false                   Only true or false
char	    2 bytes	            ' ' (blank)	            0 to 65,535 (Unicode characters)

🔹 2. Non-Primitive / Reference Data Types
---------------------------------------------
Type	               Description	                        Default Value
String	        A class (sequence of characters)	          null
Arrays	        Object that holds multiple values	          null
Custom Classes	User-defined types	                          null

📌 Notes:
String is not a primitive type, but a class in java.lang package.
All reference types default to null.
->Use long literals with L or l: long x = 123456789L;
->Use float literals with F or f: float y = 3.14F;

A new type was introduced in Java version 10
---------------------------------------------
var type
#########
-> This was introduced in Java version 10
-> It gives a dynamic datatype concept. Depending on the value stored inside the variable, the datatype is allocated to it internally.

Example:
public class C {
	public static void main(String[] args) {
		var x1 =100;
		var x2 =100.3;
		var x3 ="mike";
		var x4 =new C();
		System.out.println(x1);
		System.out.println(x2);
		System.out.println(x3);
		System.out.println(x4);
	}
  public var test(var x3) {}//Error
}
-> var type can only be a local variable
-> It cannot be a static / non-static variable
-> It cannot be a method argument
-> It cannot be a method return type

Constructors in Java
Constructors are special methods used to initialize objects when they are created.

🔹 Basic Rules:
✅ Constructor name must match the class name
❌ It is not void by default
Constructors do not have a return type, not even void
If you write void before a constructor, it becomes a method, not a constructor

Example 1:
----------
public class C {
	C(){
		System.out.println(100);//will execute successfully Output :100
		return 100;//Error
	}
	public static void main(String[] args) {
		C c1 = new C();
	}	
}

Note :
-> Method name can be the same as the class name
-> Variable name can be the same as the class name

🔁 Constructor Overloading in Java
####################################
Constructor Overloading means having more than one constructor in the same class, but with different parameter lists.

✅ Why Use Constructor Overloading?
To create objects with different levels of information or default values, depending on what’s available.

Example:
--------
public class A {
	A(){//NoofArgs=0
		System.out.println("A");
	}
	A(int x){//NoofArgs=1
		System.out.println(x);
	}
	A(int x,int y){//NoofArgs=2
		System.out.println(x);
		System.out.println(y);
	}
	public static void main(String[] args) {
		A a1 = new A();
		A a2  = new A(100);
		A a3 = new A(200,300);
	}
}

🔷 this keyword in Java
#############################
The this keyword in Java is a reference variable that refers to the current object — the object whose method or constructor is being executed.

✅ Uses of this Keyword
1. Differentiate Between Instance and Local Variables
------------------------------------------------------
When local variable names are the same as instance variables, use this to refer to the instance variable.

class Student {
    String name;
    Student(String name) {
        this.name = name;  // 'this.name' is the instance variable, 'name' is the parameter
    }
}

2. Call One Constructor from Another (Constructor Chaining)
------------------------------------------------------------
Use this() to call another constructor within the same class.

class Student {
    String name;
    int age;

    Student(String name) {
        this(name, 18);  // calls the second constructor
    }

    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
3. Pass Current Object as Argument
-----------------------------------
class Student {
    void display() {
        Helper.printStudent(this);  // pass current object
    }
}
class Helper {
    static void printStudent(Student s) {
        System.out.println("Student object: " + s);
    }
}

4. Return Current Object
---------------------------
Useful in method chaining.

class Person {
    Person setName(String name) {
        // set name
        return this;  // return current object
    }

    Person setAge(int age) {
        // set age
        return this;
    }
}

5. Access Instance Methods and Variables
-----------------------------------------
You can use this to call other instance methods or access fields within the class explicitly.

void print() {
    this.show();  // same as just calling show()
}

void show() {
    System.out.println("Hello");
}
-> this keyword is a special reference variable that hold's object's address
Example:
----------
public class A {
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1);
		a1.test();
	}
	public void test() {
		System.out.println(this);
	}
}

-> Using this keyword, we can access non-static members of the class
Example:
--------
public class A {
	int x = 10;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1.x);
		a1.test();
	}
	public void test() {
		System.out.println(this.x);
	}
}

-> We cannot use this keyword inside a "static method"
public class A {
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(this);//Error
	}
	public static void test() {
		System.out.println(this);//Error
	}
}

Example:
-------
public class A {
	int x = 10;
	int y = 10;
	public static void main(String[] args) {
		A a1 = new A();
		a1.test();
	}
	public void test() {
		System.out.println(this.x);
		System.out.println(this.y);
	}
}

-> this keyword hold's current object address that is executing

Example:
--------
public class A {
	public static void main(String[] args) {
		A a1 = new A();
		a1.test();
		A a2 = new A();
		a2.test();
		a1.test();
		
	}
	public void test() {
		System.out.println(this);
	}
}

this()- This syntax is used to call the constructor
--------------------------------------------
-> Using this() keyword, we can call a constructor

Example:
-------
public class A {
	A(){
		System.out.println("A");
	}
	A(int x){
		this();
	}
	public static void main(String[] args) {
	   A a1 = new A(100);
	}	
}

-> While calling a constructor using this() keyword, ensure calling is done from another constructor
Example:
--------
public class A {
	A(){
		System.out.println("A");
	}
	A(int x){
		this();
	}
	public static void main(String[] args) {
	   A a1 = new A(100);
	}
	public void test() {
		this();//Error, we cannot call the constructor from a method
	}	
}

Example:
---------
public class A {
	A(int x){
		System.out.println(x);
	}
	A(){
		this(100);
	}
	public static void main(String[] args) {
	   A a1 = new A();
	}	
}

-> While calling a constructor using this() keyword, ensure it is alwaysthe  first statement inside another constructor

Example:
---------
public class A {
	A(int x){
		System.out.println(x);
	}
	A(){
		System.out.println(200);
		this(100);//Error because it cannot be the second statement while calling the constructor	
	}
	public static void main(String[] args) {
	   A a1 = new A();
	}	
}

Example:
---------
public class A {
	int x;//-->0
	A(int x){////Step 4-->x=100
		this.x=x;//Step 5
		System.out.println(this.x);//Step 6===>100
	}
	A(){//Step 2
		this(100);//Step 3
	}
	public static void main(String[] args) {
	   A a1 = new A();//Step 1
	}	
}

✅ Types of Constructor Chaining
-> When we call one constructor from another constructor it will form chain like flow structure. This is called constructor chaining
🔸 1. Within the Same Class → Use this()
You can use this() to call another constructor in the same class.

✅ Example:
class Student {
    String name;
    int age;

    Student() {
        this("Unknown", 18);  // calls 2-arg constructor
        System.out.println("Default constructor called");
    }

    Student(String name) {
        this(name, 18);  // calls 2-arg constructor
    }

    Student(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Parameterized constructor called");
    }

    void display() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}
▶️ Output:
The parameterized constructor called  
The default constructor is called  
🔸 2. From Subclass to Superclass → Use super()
You can call a constructor from the parent class using super().

✅ Example:
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Student extends Person {
    Student() {
        super(); // calls Person constructor
        System.out.println("Student constructor");
    }
}

⚠️ Rules of Constructor Chaining
Rule	Description
✅ Only one constructor can be called using this() or super()	
✅ Must be the first statement in the constructor	
❌ Cannot mix this() and super() in the same constructor

###############################
Important Shortcuts in Eclipse
################################
1. Ctrl + Space:⚡ Content Assist — suggests code completions.
2. Ctrl + 1: 💡 Quick fix — suggests solutions for errors or warnings.
3. Ctrl + O: 🧭 Quick outline — shows methods/fields of the current class.
4. F3: 🔄 Go to the declaration of a variable, method, or class.
5. Ctrl + . : ➡️ Jump to the next error or warning in the file.

📦 Packages in Java
####################
A package in Java is a namespace that organizes classes and interfaces into a structured folder system, making code modular, reusable, and easy to manage.

c. Naming Convention for packages
----------------------------------
-> Package name cannot be ka eyword like - new, static, public, etc...
-> Do not start the package name with capital letters
-> Package name not to be given as java

d. When you create a class inside a package, you have to define the package keyword in your program as shown below:
Example:
package p1;
public class A {}

e. Create 2 classes in the same package and perform inheritance. Import is not required.
Example:
package p1;
public class A {}

package p1;
public class B extends A {}

f. Create 2 classes in different packages and perform inheritance. "Import required".
Example:
package p1;
public class A {}

package p2;
import p1.A;
public class C extends A{}

----------------------------------------------------------
Example:
package p1;
public class A {}

package p2;
public class C {}

package p1;
import p2.C;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
		C c1 = new C();
	}
}
---------------------------------------
Example:
package p1;
public class A {}

package p1;
public class B {}

package p2;
import p1.*;
public class C {
	public static void main(String[] args) {
		A a1 = new A();
		B b1 = new B();
	}
}
--------------------------------
Example:
package p1;
public class A {}

package p2;
public class A {}

package p3;
public class B {
	public static void main(String[] args) {
		p1.A a1 = new p1.A();//---> p1
		p2.A a2 = new p2.A();//---> p2
	}
}
---------------------------------------
#######################################
Object Oriented Programming -  Pillars
########################################

a. inheritance
b. polymorphism
c. encapsulation
d. abstraction

a. inheritance
######################
Inheritance is one of the core pillars of Object-Oriented Programming (OOP).
It allows a class (subclass) to inherit fields and methods from another class (superclass).

✅ Why Use Inheritance?
Code reusability
Improves maintainability
Supports method overriding & polymorphism

Example :
package app_java_1;
public class Animal {
	public void eat() {
		System.out.println("Eating");
	}
	public void sleep() {
		System.out.println("sleeping");
	}
}

package app_java_1;
public class Dog extends Animal{
	//eat(),sleep()--->Animal
}

package app_java_1;
public class Cow extends Animal{
	//eat(),sleep()--->Animal
}

package app_java_1;
public class Root {
	public static void main(String[] args) {
		Dog d = new Dog();
		d.eat();
		d.sleep();
		System.out.println("_______");
		Cow cow = new Cow();
		cow.eat();
		cow.sleep();
	}
}

Example 3: Multilevel inheritance
-----------------------------------

package app_java_1;
public class A {
	public void test1() {
		System.out.println(1);
	}
}
package app_java_1;
public class B extends A{
	public void test2() {
		System.out.println(2);
	}
}
package app_java_1;
public class C extends B{
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();//Output :1
		c1.test2();//Output :2
	}
}

------------------------------------------------------------------------------
################################################################################################
What is multiple inheritance?
Answer: When a child class has more than one parent class, it is called multiple inheritance
################################################################################################

Note: Java classes do not support multiple inheritance because of the diamond problem.

 Diamond Problem in Java (Multiple Inheritance Problem)
---------------------------------------------------------
The Diamond Problem occurs in multiple inheritance when a class inherits from two classes that have a common superclass, leading to ambiguity about which method to inherit.

Suppose we inherit a method from A->B->D,  and the Same method is inherited from A->C->D, then confusion arises from which parent class method is inherited by the child class D. This is called as DIAMOND PROBLEM. Hence in java classes does not support multiple inheritance.

Note: We can do mulitple inheritance on interface.

Example: Multiple inheritance error
------------------------------------------
package app_java_1;
public class A {}

package app_java_1;
public class B{}

package app_java_1;
public class C extends A, B{//Error
	
}

###############################
Access Specifiers in Java
###############################

| Access Context                | `public` |         `protected`          | `default` (no modifier)   | `private`  |
| ------------------------------| :------: | :------------------------:   | :---------------------:   | :-------:  |
| Same Class                    |     ✅   |              ✅             |            ✅            |     ✅     |
| Same Package                  |     ✅   |              ✅             |            ✅            |     ❌     |
| Subclass in Same Package      |     ✅   |              ✅             |            ✅            |     ❌     |
| Non-Subclass in Same Package  |     ✅   |              ✅             |            ✅            |     ❌     |
| Subclass in Other Package     |     ✅   | ✅ *(via inheritance only)* |            ❌            |     ❌     |
| Non-Subclass in Other Package |     ✅   |              ❌             |            ❌            |     ❌     |

a. private: When a variable/method is made private, then we can access that in the same class but not outside the class

b. default: A variable/method with default access specifier can work only inside the same class or the same package, but cannot be accessed in a different package

c. protected: We can access variables/methods in the same class/same package, and inside different packages only when inheritance is done

d. public: When we make a variable/method public, then we can access that in the same class/the same package/different package

########################################################
Access Specifier on Constructors
#######################################################

Can we inherit the Constructor?
Answer: We cannot inherit the constructor

🔐 Private Constructor in Java
A private constructor is a constructor that cannot be accessed outside its class.

✅ Why Use a Private Constructor?
❌ Prevent object creation	        for utility or helper classes
✅ Implement Singleton Pattern		Ensure only one instance is created
🔐 Hide object instantiation		Force object creation through factory methods
-> If a constructor is made private, then its object cannot be created outside the class.

Example :
package p1;
public class A {
	private A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();//--->Error
	}
}
package p2;
import p1.A;
public class C {
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}
-> When a constructor is made private, then inheritance of that class is not allowed
(Note: Constructs are not inherited)

Example 2:
----------
package p1;
public class A {
	private A() {}	
}

package p1;
public class B extends A{//-->Error	
}

package p2;
import p1.A;
public class C extends A{//-->Error	
}


🏗️ Default Constructor in Java
################################
A default constructor is a no-argument constructor that the Java compiler automatically provides if you do not define any constructors in your class.

✅ Key Features:
Feature					Description
No parameters. 				Takes zero arguments
Provided automatically			Only if no constructor is defined by the user
Initializes variables,			sets fields to default values (e.g., 0, null)
Used for object creation		Allows creation of objects without parameters
-> If a constructor is made default, then its object can be created in the  same class/same package, but not outside the package.

Example 1:
----------
package p1;
public class A {
	A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p2;
import p1.A;
public class C{
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}

-> When a constructor is made default, then inheritance of that class is allowed only in the same package, but not outside the package

Example 2:
----------
package p1;
public class A {
	A() {}
}
package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A{//-->Error	
}

🔐 Protected Constructor in Java
#################################
A protected constructor means the constructor can only be accessed:

✅ Within the same package
✅ From subclasses (even in other packages)

✅ Why Use a Protected Constructor?
->To restrict object creation outside the package
->To allow subclassing but prevent direct instantiation from unrelated classes
->Often used in inheritance-based designs, frameworks, or abstract factories

Example 1:
---------
package p1;
public class A {
	protected A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p1;
public class B  {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p2;
import p1.A;
public class C {
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}
-> When a constructor is made protected, then inheritance of that class is  allowed inthe  same package / outside the package (both)
(Note: Constructors are not inherited)

Example 2:
----------
package p1;
public class A {
	protected A() {}
}

package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A {}

e. public Constructor
------------------------
-> If a constructor is made public, then its object can be created in the same class/same package and outside the package also

Example 1:
---------
package p1;
public class A {
	public A() {}
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

package p1;
public class B  {
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

package p2;
import p1.A;
public class C  {
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

-> When a constructor is made public, then inheritance of that class is  allowed in the same package / outside the package (both)
(Note: Constructors are not inherited)

Example 2:
----------
package p1;
public class A {
	public A() {}
}

package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A {}

########################################
✅ Access Specifiers on Top-Level Classes:
Access Specifier			Usage					Visibility
public					public class ClassName {}		Visible to all classes everywhere (within the same package or other packages).
Default (no modifier)			class ClassName {}			Visible to classes within the same package only.

❌ Not allowed on top-level classes:
private
protected

These are invalid for top-level classes and will cause a compile-time error if used.

Example 1:
package p1;
class A {}

package p1;
public class B extends A{} //Because A is default and inherited in B

package p2;
import p1.A;//-->Error
public class C extends A{//-->Error	
}

Example 2:
package p1;
class A {
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p2;
import p1.A;//--->Error because A is default and cannot be inherited in another package
public class C {
	public static void main(String[] args) {
		A a1 = new A();//--->Error
	}
}

What happens when a class is made public?
Answer:
->  Its object can be created in the same class/same package & inside a different package
-> Inheritance is allowed in the same package & inside different packages

Example :

package p1;
public class A {}

package p1;
public class B extends A{}

package p2;
import p1.A;
public class C extends A{}

Note:
------------------------------------------------------------------
a. Compile Time
->This is the phase where source code is checked and translated into bytecode.
->Java source files (.java) are compiled by the Java Compiler (javac).
->The compiler checks for syntax errors and converts the code into bytecode (platform-independent code).

Output: .class file containing bytecode.

Command: javac MyProgram.java
Result: Creates MyProgram.class file.

b. Run Time
->This is the phase where the compiled bytecode is executed by the Java Virtual Machine (JVM).
->The JVM loads the .class file and executes the bytecode.
->Any exceptions or logical errors may occur during this phase.

Command: java MyProgram
Result: Runs the program using the bytecode inside MyProgram.class.

-----------------------------------------------------------------------------------
Two types of polymorphism

a. Overriding (Run-time polymorphism):
->Overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass.
->It is used to achieve Run-time Polymorphism.
->The method signature (name + parameters) must be exactly same in both parent and child class.
-> The decision of which method to call is made at run-time, not compile-time.

🔸 Key Rules of Method Overriding:
Rule							Description
Same method signature					Method name, return type, and parameters must be the same.
Access modifier						Child method must have the same or more accessible modifier (e.g., can’t override public with private).
Inheritance						Only possible in an IS-A relationship (subclass-superclass).
Can't override final, static, or private methods	These are either not inherited or cannot be changed.
Return type						should be the same or covariant (child class return type).
Use @Override						Optional, but recommended to catch errors at compile time.

Example:
package p1;
public class GoldAccount {
	public void onlineBanking() {
		System.out.println("yes");
	}
	public void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
	public void rateOfInterest() {
		System.out.println("6% PA");
	}
	public static void main(String[] args) {
		PlatinumAccount p = new PlatinumAccount();
		p.onlineBanking();
		p.rateOfInterestOutput: 6% PA
		System.out.println("--------");
		GoldAccount g = new GoldAccount();
		g.onlineBanking();
		g.rateOfInterest();//-->Output: nill
	}
}

 What are Annotations?
->Introduced in Java 5, annotations are metadata that provide information to the compiler or runtime environment.
->They do not directly affect program logic but can instruct the compiler or tools to perform specific actions.

 Common Use: @Override
--------------------------
->@Override is used to indicate that a method is intended to override a method in the superclass.
->It helps the compiler catch errors if the method does not override anything (e.g., due to a typo or mismatch in method signature).

package p1;
	public class GoldAccount {	
		public void rateOfInterest() {
			System.out.println("nill");
		}
	}

package p1;
public class PlatinumAccount extends GoldAccount {
	@Override
	public void rateOfInterests() {//-->Error because method name mismatch
		System.out.println("6% PA");
	}	
}

Question: Access Specifier should it be the same or can it be different during Overriding?
Answer: During overriding, we can increase the scope of the access specifier, but we cannot reduce the scope of the access specifier

Example 1:
package p1;
public class GoldAccount {
	void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
//No Error Because the default scope is increased to public	
	@Override
	public void rateOfInterest() {
		System.out.println("6% PA");
	}
}
-------------------------------------------------------------------
Example 2:

package p1;
public class GoldAccount {
	public void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
//Error: Because the public scope is reduced to the default
	@Override
	void rateOfInterest() {
		System.out.println("6% PA");
	}
}

Order of Access Specifiers
Private -> Default -> Proctected -> Public

Example 3:
-----------
package p1;
public class GoldAccount {
	private void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
//Error: Because private methods, we cannot inherit
//Without inheritance, overriding cannot be done
	@Override
	protected void rateOfInterest() {
		System.out.println("6% PA");
	}
}
###############################
Note: -> Static members cannot be inherited
Example:
You have:
A parent class: GoldAccount (in package p1)
A child class: PlatinumAccount extends GoldAccount

// GoldAccount.java
package p1;
public class GoldAccount {
    static int x = 100;
    public static void rateOfInterest() {
        System.out.println("nill");
    }
}

// PlatinumAccount.java
package p1;

public class PlatinumAccount extends GoldAccount {
    public static void main(String[] args) {
        PlatinumAccount.rateOfInterest();      // Output:  nill
        System.out.println(PlatinumAccount.x); // Outuput: 100
    }
}

🔍 What Is This Program Teaching?
✅ 1. Static Methods and Variables Are Not Polymorphic
Even though PlatinumAccount inherits from GoldAccount, calling:
PlatinumAccount.rateOfInterest();
is resolved at compile-time based on the class name, not on the object type.

Since PlatinumAccount does not override the method (it doesn’t define its own rateOfInterest()), calling: PlatinumAccount.rateOfInterest(); 
is effectively the same as: GoldAccount.rateOfInterest();

The same logic applies to the static variable x:
PlatinumAccount.x; // resolves to GoldAccount.x (100)
🟨 Important Point:
Static methods and variables are resolved based on class name, not overridden, and not polymorphic.

################################################
Can we override static methods?
❌ No, we cannot override static methods in Java.
🔹 Explanation:
In Java, static methods belong to the class, not to instances (objects). Therefore, they are not subject to polymorphism and cannot be overridden like instance methods.

When you define a static method in a subclass with the same signature as in the superclass, it's called: ✅ Method Hiding, not Overriding.

Example:
class A {
    static void show() {
        System.out.println("Static method from A");
    }
}

class B extends A {
    static void show() {
        System.out.println("Static method from B");
    }
}

public class Test {
    public static void main(String[] args) {
        A obj = new B();
        obj.show();  // Output: Static method from A
    }
}

🔍 Why is the output a Static method from A?
Because obj is of type A, and static methods are resolved at compile-time using reference type, not the actual object.

So A.show() is called, not B.show().

🛑 Using @Override on a static method:
class C {
    static void hello() {}
}

class D extends C {
    @Override // ❌ Compile-time error!
    static void hello() {}
}

Note: During overriding method return type should match

✅ Overloading in Java (Compile-Time Polymorphism)
🔹 What is Method Overloading?
->Method Overloading means defining multiple methods with the same name in a class but with different parameter lists (type, number, or order of parameters).
->It allows compile-time polymorphism, where the method to be called is determined at compile time based on the method signature.

🔸 Characteristics of Overloading:
Feature					Description
Method name				Must be the same
Parameter list				Must be different (type, number, or order)
Return type				Can be same or different, but doesn't affect overloading
Access modifier				Can be same or different
Inheritance				Not required for overloading
Polymorphism type			Compile-time polymorphism

Example:
package p1;

public class EmailService {
	public void sendEmail(String to, String subject, String message) {
		System.out.println("Email sending....");
	}
	public void sendEmail(String to, String subject, String message, String filePath) {
		System.out.println("Email sending with attachment.....");
	}
	public static void main(String[] args) {
		EmailService service = new EmailService();
		service.sendEmail("mike@gmail.com", "Welcome", "Some Message","G:\\image.png");
	}
}

################################
Final Keyword
################################
-> If you make a variable final, then we cannot change its value(Just like constant variables)
-> If you make a static/non-static variable final, then initialization is mandatory
-> If you make a method final, then overriding is not allowed
-> If you make a class final, then inheritance is not allowed

Example 1: 
----------
package p1;

public class A {
	public static void main(String[] args) {
		final int x = 10;
		x=20;//-->Cannot change the value of final variable

		final int y;//->final mandatory to be initialized
	        final static int z;//->final mandatory to be initialized
	        //The above errors are called blank field errors
		System.out.println(y);
	}
}

Example 2:
----------
package p1;

public class A {
	final public void test() {
		System.out.println(100);
	}
}
package p1;

public class B extends A{
	@Override
	public void test() {//--> Error because we cannot override final methods
		System.out.println(100);
	}
}

Example 3:
----------
package p1;

final public class A {}
package p1;

public class B extends A{//---> Error because we cannot inherit final class	
}

#####################################
interfaces in java - abstraction
#######################################
✅ Interfaces in Java – Abstraction
Interfaces are a fundamental feature in Java used to achieve abstraction and enforce design contracts between classes.

🔹 Key Points:
Complete Abstraction (Java 7)
➤ In Java 7 and earlier, interfaces could only have abstract methods (no method bodies).
➤ They define what should be done, not how.

All Variables Are public static final
➤ Any variable declared in an interface is implicitly:
public static final (i.e., a constant).
➤ No need to specify these modifiers—they are applied by default.

Contract-Based Programming
➤ An interface defines a contract. Any class that implements the interface must provide concrete implementations for all its methods.

No Object Creation
#############################
Note: Drawback of inheritance
#############################
-> Inheritance results in tightly couple programming. Interfaces cannot be instantiated directly because they can contain incomplete methods (abstract methods).

Loose Coupling
➤ Interfaces help in decoupling code. The implementing class can change internally without affecting users of the interface.

Improves Design and Flexibility
➤ It forces implementing classes to use the same method signatures, promoting a standard structure and ensuring interoperability.

Multiple Inheritance Support
➤ Java does not support multiple inheritance with classes, but it does through interfaces. A class can implement multiple interfaces.

Example 1:
---------
package p1;

public interface A {
	public void test1() {//-->Error because complete methods are not allowed in an interface	
	public void test2(); //Correct version
	}
}

Example 3:
----------
package p1;

public interface NotificationService {
	//What needs to be implemented
	public void emailService();
	public void whatsAppService();
	public void smsService();
}

package p1;

public class NotificationServiceImpl implements NotificationService {
	//How it will be implemented
	@Override
	public void emailService() {
		System.out.println("Email Sending");
	}
	@Override
	public void whatsAppService() {
		System.out.println("Whats app Sending");
	}
	@Override
	public void smsService() {
		System.out.println("SMS Sending");
	}
	public static void main(String[] args) {
		NotificationServiceImpl impl = new NotificationServiceImpl();
		impl.emailService();
		impl.smsService();
		impl.whatsAppService();
	}
}

✅ Note: Drawback of Inheritance – Tightly Coupled Programming
🔹 What is Tightly Coupled Programming?
➤When two or more classes are highly dependent on each other's implementation, they are said to be tightly coupled.
➤In such a setup, changing one class often requires changes in the other, reducing flexibility, maintainability, and scalability.

🔸 How Inheritance Causes Tight Coupling:
➤Child class depends heavily on parent class:
➤In inheritance, the child class inherits both behavior and structure from the parent.
➤If the parent class changes, it can break or affect the behavior of all child classes.

Strong binding:
➤The child class is strongly bound to the specific parent class.
➤You cannot easily switch to a different parent or change the inheritance hierarchy without impacting the child classes.

Hard to maintain and extend:
➤Over time, inherited code becomes fragile.
➤Multiple levels of inheritance (deep hierarchy) make debugging and updates difficult.

Example:
----------
package p1;

public interface Calculator {
	public void add(int x, int y);
	public void mul(int x, int y);
}

package p1;
public class OrdinaryCalc implements Calculator{
	@Override
	public void add(int x, int y) {
		System.out.println(x+y);
	}
	@Override
	public void mul(int x, int y) {
		System.out.println(x*y);
	}
}

package p1;

public class SciCalc implements Calculator{
	@Override
	public void add(int x, int y) {
		System.out.println(x*x+y*y);
	}
	@Override
	public void mul(int x, int y) {
		int num1 = x*x;
		int num2 = y*y;
		System.out.println(num1*num2);
	}
}
package p1;

public class MainCalc {
	public static void main(String[] args) {
		OrdinaryCalc oc = new OrdinaryCalc();
		oc.add(10, 20);
		oc.mul(10, 20);
		SciCalc sc = new SciCalc();
		sc.add(10, 20);
		sc.mul(10, 20);
	}
}

✅ Advantages of Interfaces in Java
1. Abstraction
➤Interfaces facilitate complete abstraction.
➤They allow you to hide implementation details and only expose what needs to be done, not how.

Example: A Database interface may define connect(), disconnect(), but not how these are implemented.

2. Contract Enforcement
➤When a class implements an interface, it must implement all its methods.
➤This imposes a strict contract on the class, ensuring consistency in structure and behavior across multiple classes.

3. Good Design Practices
➤Interfaces promote clear separation of responsibilities.
➤They lead to clean, modular, and testable code.
➤Developers can work independently on the interface and its implementations.

4. Loose Coupling
➤Classes that use interfaces depend only on method signatures, not on concrete implementations.
➤This allows changes in implementations without affecting dependent classes.
➤Enhances flexibility, extensibility, and maintainability of the system.

5. Multiple Inheritance
➤Java doesn’t support multiple inheritance with classes, but a class can implement multiple interfaces.
➤This allows a class to inherit behavioral capabilities from multiple sources.

6. Supports Plug-and-Play Architecture
➤Interface-based design makes it easy to swap implementations (e.g., using different payment gateways, databases, or services) without changing the dependent code.

7. Better Testability and Mocking
➤Interfaces enable easier unit testing with mock implementations.
➤You can test components in isolation by mocking interface behaviour.

Note: ➤All Variables by default in an interface are final and static. Hence, initialization is mandatory.

Example:  
---------
public interface A {
	int MAX_VAL=100;
	static final int MIN_VAL=0;
}
package p1;

public class B {
	public static void main(String[] args) {
		System.out.println(A.MAX_VAL);//Output: 100
		System.out.println(A.MIN_VAL);//Output: 0
	}
}

Note:
➤Class to Class Inheritance --> extends
➤Interface to Interface Inheritance --> extends
➤Interface to Class Inheritance --> implements

Example :
---------
package p1;

public interface A {
	public void test1();
}

package p1;

public interface B extends A{
	public void test2();
}

public interface D{
	public void test3();
}

package p1;

public class C implements B, D { //If you do multiple inheritance on a class, then its parent should be interfaces only

	@Override
	public void test1() {
		System.out.println("From test1");
	}
	@Override
	public void test2() {
		System.out.println("From test2");
	}

	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

Example 4:
----------
➤ In class can we perform extends and implements together
➤But ensure the extension is used first and then implementes

package p1;
public interface A {
	public void test2();
}

package p1;
public class B {
	public void test1() {
		System.out.println("From test1");
	}
}

package p1;
public class C extends B  implements  A {
	@Override
	public void test2() {
		System.out.println("From test2");		
	}
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

Question: Can I develop an incomplete static method in an interface?
Answer: We cannot inherit static methods & override, hence incomplete static methods are not allowed in an interface

Example:
package p1;
public interface A {
	public static void test2();//-------> Error
}

Java 8 Features
###################
1. default keyword:
➤Using the default keyword, we can create complete methods inside an interface. This was introduced in Java version 8

Example :
package javaconcepts.p3;

public interface A {
	default public void test1() {
		System.out.println("From test1");
	}
	public void test2();
}
package javaconcepts.p3;

public class B implements A {

	public static void main(String[] args) {
		B b1 = new B();
		b1.test1();
		b1.test2();
	}
	@Override
	public void test2() {
		System.out.println("From Overrided test2");
	}	
	@Override
	public void test1() { //we can override the method
		System.out.println("From Overrided Test1");
	}
}
Output
From Overrided Test1
From Overrided test2

✅ 2. Functional Interface
🔹 Definition:
➤A Functional Interface is an interface that has exactly one abstract (incomplete) method.
➤Can have multiple default or static methods (complete methods).
➤ It enables lambda expressions and functional programming in Java.

🔸 Key Points:
➤A functional interface must contain only one abstract method.
➤You can add any number of default or static methods (they're considered complete methods).
➤If the interface inherits more than one abstract method (from multiple interfaces), it no longer remains a functional interface, and the compiler throws an error.
➤Use @FunctionalInterface annotation to enforce the rule at compile-time.

Example 1:
--------------------
@FunctionalInterface
public interface A {//Error-> Because cannot have ZERO incomplete method
}

Example 2:
----------
@FunctionalInterface
public interface A {
	public void test1();
}
Output:  No Error because it has exactly one incomplete method

Example 3:
----------
@FunctionalInterface
public interface A {//Error->A functional interface should consist of exactly one //incomplete method inside it
	public void test1();
	public void test2();
}

Example 4:
----------
package p1;
@FunctionalInterface
public interface A {
	public void test1();
	default public void test2() {
		System.out.println("From Test 2");
	}
	default public void test3() {
		System.out.println("From Test 3");
	}
}
package p1;
public class B implements A {
	public static void main(String[] args) {
		B b1 = new B();
		b1.test1();
		b1.test2();
		b1.test3();
	}
	@Override
	public void test1() {
		System.out.println("From test 1");
	}
		
}
Output:
---------
From test 1
From Test 2
From Test 3

Example 5:
-----------
package p1;
public interface A {
	public void test1();
}

package p1;
@FunctionalInterface
public interface B extends A{}
Output: No Error

Example 6:
----------
package p1;
public interface A {
	public void test1();
	public void test2();
}
package p1;
@FunctionalInterface
public interface B extends A{}
Output: Error because we are inheriting 2 methods to a functional interface

Example 6:
---------
package p1;
public interface A {
	public void test1();	
}

package p1;
@FunctionalInterface
public interface B extends A{
	public void test2();
}
Output: Error because we are inheriting 1 method from a functional interface, and a functional interface has 1 method, which totals to 2 methods in an interface

🔹 Definition:
A Lambda Expression is a short block of code which:
➤Takes in parameters
➤Executes a body
➤Can be used in place of anonymous classes
➤Requires a functional interface to work

🔸 Key Points:
✅ Introduced in Java 8
Part of Java’s functional programming enhancements.

✅ Reduces Code Length
Allows writing concise code by eliminating boilerplate like anonymous class syntax.

✅ Works With Functional Interfaces
Lambda expressions can only be used where a functional interface (i.e., one abstract method) is expected.

✅ Commonly Used in Stream API
Lambdas are widely used in filtering, mapping, sorting, and reducing data in the Java Stream API.

🔹 Syntax of Lambda Expression:
(parameters) -> { body }

Examples:
(x, y) -> x + y
name -> System.out.println("Hello " + name)
() -> System.out.println("No parameters")

✅ How Lambda Expressions Work in Java?
🔹 Basic Concept
At a high level, lambda expressions in Java work by:
➤ It creates an anonymous class behind the scenes. A class without any name is called Anonymous.
➤Then the lambda expression creates an object and loads the method by implementing it inside the object.
➤Then we use an object reference to call that implemented method
➤Replacing instances of anonymous classes that implement functional interfaces with a concise, inline function-like syntax.

🔸 ✅ Behind the Scenes:
When you write a lambda expression like: () -> System.out.println("Hello");
Java performs the following under the hood:
➤Infers the target type based on the context. → It must be a functional interface.
➤Converts the lambda into an instance of the functional interface using invokedynamic bytecode instruction (introduced in Java 7).
➤Creates a synthetic method and links the lambda expression to it at runtime.

🔹 Step-by-step Breakdown:
✅ Step 1: Functional Interface
@FunctionalInterface
interface Greet {
    void sayHello();
}

✅ Step 2: Lambda Expression
Greet g = () -> System.out.println("Hello");
g.sayHello();

➡ This is functionally equivalent to:
Greet g = new Greet() {
    public void sayHello() {
        System.out.println("Hello");
    }
};
But the lambda version is shorter, cleaner, and faster.

🔹 Functional Interface Matching
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

MathOperation add = (a, b) -> a + b;
System.out.println(add.operate(5, 3)); // 8
➡ Java matches the lambda (a, b) -> a + b to the method operate(int,int).

Note: Functional Programming defines you to say "what you want, not how to do it step-by-step"

Example 1:
------------
package p1;
@FunctionalInterface
public interface A {
	public void test1();	
}
package p1;
public class B{
	public static void main(String[] args) {
		A a1 = ()->{
			System.out.println(100);
		};
		a1.test1();// Output: 100
	}
}

Example 2:
----------
package p1;
@FunctionalInterface
public interface A {
	public void test1(int x);
	default public void test2() {
		System.out.println("test2");
	}
}
package p1;
public class B{

	public static void main(String[] args) {
		A a1 = (int y) -> {
			System.out.println(y);
		};
		a1.test1(100);// Output: 100
		a1.test2();// Output: test2
	}
}

✅ How it works: Lambda Expression with Functional Interface
In Java 8+, when you have a functional interface (i.e., an interface with only one abstract method), you can use a lambda expression to provide the implementation without creating a class that implements A.

🔹 Behind the Scenes:
This line:
A a1 = () -> {
    System.out.println("This is the test1 function");
};
...is a shortcut for writing:

A a1 = new A() {
    @Override
    public void test1() {
        System.out.println("This is the test1 function");
    }
};
✅ So the lambda automatically becomes the implementation of test1() in the background.

✅ Do We Need to Implement the Functional Interface Manually?
➤No, you do not need to use implements InterfaceName at all, regardless of:
➤Whether the functional interface is in the same package
➤Or in a different package

✅ What You DO Need:
| Requirement                                                               | Mandatory?     | Explanation                               |
| ------------------------------------------------------------------------- | -------------- | ----------------------------------------- |
| Interface must be `@FunctionalInterface`                                  | ✅              | Must have exactly one abstract method     |
| Interface must be **accessible** (i.e., `public` if from another package) | ✅              | You must import it properly               |
| Same package                                                              | ❌ Not required | Lambda works across packages              |
| Class must `implements A`                                                 | ❌ Not required | Lambda already handles the implementation |

4. Stream API
---------------------
Note: to learn Stream API, complete the following first
a. Collection (Data Structure)
b. Functional Programming

5. Optional class - We have to learn the exception concept in Java first
-----------------------------------------------------------------------
Note: What are marker interfaces in Java?
-> Empty interfaces in Java are called a marker interface

Example: For the marker interface
package p1;
public interface A {}
