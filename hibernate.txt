🔷 Hibernate
➤ Hibernate is an Object Relational Mapping (ORM) framework in Java.
➤ It maps Java classes to database tables and Java objects to table rows.
➤ It removes the need to write raw SQL queries by providing an abstraction layer.
➤ CRUD operations are automated and handled internally by Hibernate.
➤ It is an implementation of JPA (Java Persistence API) specification.

🔷  Features of Hibernate
👉 ORM support → Direct mapping between Java objects and database tables.
👉 Database Independent → Code works with multiple RDBMS without changes.
👉 HQL (Hibernate Query Language) → Object-oriented query language.
👉 Caching support → Improves performance using first-level and second-level cache.
👉 Lazy Loading → Data fetched only when required.
👉 Automatic Table Creation → Schema generation can be managed.
👉 Transaction Management → Integrated with Java Transaction API(JTA) and Java Database connectivity(JDBC) transactions.

🔷 Advantages of Hibernate
➤ Eliminates boilerplate JDBC code.
➤ Portable across different databases.
➤ Improved productivity → Less code, more functionality.
➤ HQL provides flexibility compared to SQL.
➤ Performance optimization using caching and batch fetching.
➤ Easy relationship management between entities (@OneToOne, @OneToMany, etc.).

🔷 Hibernate Architecture
🌟 Application Starts → Configuration Loaded
➤ Hibernate first loads its configuration (usually hibernate.cfg.xml or application.properties in Spring Boot).
➤ This file contains:
    🔗 DB connection info (URL, username, password).
    🔗 Hibernate dialect (e.g., MySQLDialect).
    🔗 Entity class mappings (Employee.class, etc.).
➤ Hibernate builds a Configuration object in memory.

🌟 SessionFactory Creation
➤ From the configuration, Hibernate creates a SessionFactory.
➤ SessionFactory is a heavyweight, thread-safe object, created once per application.
➤ It:
    🔗 Reads all mappings (e.g., @Entity annotations).
    🔗 Prepares SQL templates for CRUD operations.
    🔗 Maintains a connection pool.
👉 Think of SessionFactory as a blueprint for working with the database.

🌟 Session Opening
➤ When you need to interact with DB, you call:
➤ Session session = sessionFactory.openSession();
Session is a lightweight, short-lived object (not thread-safe).
➤ It represents a unit of work with the database.

🌟 Transaction Begins
➤ Hibernate uses Transaction API (backed by JDBC or JTA).
➤ When you call:
    Transaction tx = session.beginTransaction();
➤ Hibernate ensures ACID properties:
    All queries either succeed (commit) or fail together (rollback).

🌟 Object State Management
Hibernate tracks objects in three states:
✔️ Transient → new Java object (not linked to DB/session).
✔️ Persistent → after calling session.save(obj), Hibernate tracks it. Any changes are auto-synced to DB.
✔️ Detached → once the session is closed, objects are no longer tracked.

🌟 Hibernate Converts Objects → SQL
Example:
Employee emp = new Employee();
emp.setId(1);
emp.setName("John");
emp.setSalary(50000);
session.save(emp);

Behind the scenes, Hibernate generates SQL:
insert into Employee (id, name, salary) values (1, 'John', 50000);

➤ Hibernate uses Dialect (e.g., MySQLDialect, OracleDialect) to generate SQL that matches the DB vendor.
➤ It then executes the query via JDBC internally.

🌟 Caching & Optimization
➤ Hibernate uses First-Level Cache (Session scope) automatically → if you call session.get(Employee.class, 1) multiple times in the same session, Hibernate only queries the DB once.
➤ It can also use Second-Level Cache (SessionFactory scope) to cache data across sessions.

🌟 Transaction Commit or Rollback
➤ On tx.commit():
    🔗 Hibernate flushes all pending changes (dirty checking).
    🔗 Executes SQL statements.
    🔗 Commits the JDBC/JTA transaction.
➤ On tx.rollback():
    🔗 All operations are discarded.

🌟 Session Close
➤ After commit/rollback, the session is closed:
session.close();
➤ Persistent objects become detached.
➤ Session’s first-level cache is cleared.

✅Flow:
Application → SessionFactory → Session → Transaction → Database

🔷Difference between Hibernate and JDBC
| Aspect                     | JDBC (Java Database Connectivity)                                                                   | Hibernate                                                                             |
| -------------------------- | ------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| Definition             | A Java API to connect and execute SQL statements directly with relational databases.                | An ORM framework that maps Java objects to database tables and automates persistence. |
| Level of Work          | Low-level → You write SQL manually and handle DB logic.                                                 | High-level → Works with Java objects, Hibernate generates SQL.                            |
| Boilerplate Code       | Requires a lot of code (`Connection`, `Statement`, `ResultSet`, exception handling, closing resources). | Minimal code → Hibernate manages connection, query execution, mapping automatically.      |
| Query Language         | Uses SQL (Structured Query Language).                                                               | Uses HQL (Hibernate Query Language) and Criteria API (object-oriented queries).       |
| Database Independence  | SQL is database-specific → migration to another DB requires changes.                                | Database-independent → Hibernate dialects handle DB differences.                          |
| Mapping                | Manual → you map ResultSet columns to Java objects.                                                     | Automatic ORM mapping between Java class and DB table.                                    |
| Transaction Management | Manual → developer must call `commit()` / `rollback()`.                                                 | Built-in → integrates with JDBC or JTA for transaction handling.                  |
| Caching                | No caching → always hits the database.                                                                  | Built-in First-level & Second-level caching for performance.                          |
| **Relationships          | Developer must handle foreign keys manually with SQL joins.                                             | Relationships (`@OneToOne`, `@OneToMany`, `@ManyToMany`) handled automatically.           |
| Productivity           | Lower → more boilerplate, repetitive work.                                                              | Higher → less code, faster development.                                                   |


✅Example Code Snippet: Entity Class Employee

@Entity
public class Employee {	
	@Id
	private int id;
	private String name;
	private float salary;
	
	//setters
	public void setId(int id) {
		this.id = id;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public void setSalary(float salary) {
		this.salary = salary;
	}

	//Getters
	public int getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public float getSalary() {
		return salary;
	}	
}

⚡ Explanation:
➤ @Entity → tells Hibernate: “This class should be mapped to a database table.”
➤ By default, table name = class name (Employee).
➤ @Id → tells Hibernate which field is the primary key column in the table.
➤ Other fields (name, salary) will be mapped as columns in the table.

✅Flow Diagram:
Employee class  <-->  Employee table
id              <-->  primary key column
name            <-->  column name
salary          <-->  column salary

🔷 Hibernate Annotations
✔️ @Entity → Marks a class as an entity.
✔️ @Table(name="...") → Maps class to table.
✔️ @Id → Marks primary key field.
✔️ @GeneratedValue → Defines primary key generation strategy.
✔️ @Column(name="...") → Maps property to a column.

Relationships:
✔️ @OneToOne
✔️ @OneToMany
✔️ @ManyToOne
✔️ @ManyToMany

🔷 JPA
👉JPA (Java Persistence API) is a specification, not an implementation.
👉It defines a standard set of interfaces, annotations, and rules for persisting Java objects into relational databases.
👉JPA itself does not provide the actual code — it’s like a contract that ORM tools must follow.

Example JPA annotations:
@Entity, @Id, @Table, @Column

Example JPA interface:
EntityManager (similar to Hibernate’s Session)

👉 Think of JPA as a blueprint: It only says “this is how persistence should be done”, but does not do the work itself.

🔷 Relation between Hibernate and JPA
➤ Hibernate is an implementation of JPA.
➤ It provides the actual code that fulfills JPA specifications.
➤ It extends JPA and adds extra features not covered by JPA, like:
    🔗 Hibernate Query Language (HQL)
    🔗 Advanced caching
    🔗 Better performance tuning options

➤ Other JPA implementations besides Hibernate:
    🔗 EclipseLink
    🔗 OpenJPA
    🔗 DataNucleus

👉 Think of Hibernate as a real car built from JPA’s design:
JPA = design/specification
Hibernate = actual car (with even more features)

✅ Tip:
What is the difference between JPA and Hibernate?
✔️ JPA is a specification (interfaces + annotations, no implementation).
✔️ Hibernate is an implementation of JPA, plus it offers additional features.
✔️ So, when you write JPA code, you’re usually running it on Hibernate underneath.

🔷 Hibernate Mappings

🌟 OneToMany Mapping
➤ One record in Table A is related to multiple records in Table B.
➤ Annotation: @OneToMany
✅ Example:
    1. In an E-commerce application, one Customer can have multiple Delivery Addresses saved in their profile.
    2. In a Banking system, one Bank Branch can have multiple Accounts.
    3. In a Healthcare system, one Doctor can have multiple Patients assigned.

🌟 ManyToOne Mapping
➤ Multiple records in Table A map to one record in Table B.
➤ Annotation: @ManyToOne
✅ Example:
    1. In an E-commerce system, many Orders belong to one Customer.
    2. In a Corporate HR system, many Employees report to one Department.
    3. In a Travel Booking platform, many Flight Bookings are associated with one User.    

🌟 ManyToMany Mapping
➤ Records in one table are associated with multiple records in another table and vice versa.
➤ Annotation: @ManyToMany
✅ Example:
    1. In a Learning Management System (LMS), many Students can enroll in many Courses.
    2. In a Job Portal, many Candidates can apply to many Job Postings.
    3. In a Music Streaming App, many Artists can be part of many Playlists, and playlists can include multiple artists.    

🌟 OneToOne Mapping
One record in Table A maps exactly to one record in Table B.
Annotation: @OneToOne
✅ Example:
    1. In a Banking application, one Customer has exactly one PAN Card or KYC record.
    2. In an HR system, one Employee has exactly one EmployeeProfile record (with DOB, address, etc.).
    3. In a Car Rental app, one Car has exactly one Insurance Policy.    


🔷 Normalization
A database design technique to organize data efficiently.

Goals:
✔️ Reduce redundancy (no unnecessary repetition of data).
✔️ Improve data consistency and integrity.
✔️ Break a large unstructured table into smaller, related tables.  

Forms of Normalization:
🌟 First Normal Form (1NF)

Rules:
👉 Each column must have atomic values (no multiple values in a single cell, e.g., "CS, IT").
👉 Values in a column must be of the same data type (no mixing, e.g., phone number + email in one column).
👉 Each row must be unique → requires a primary key.
👉 No repeating groups or arrays allowed.

✅ Example (Before 1NF):
| StudentID | Name | Subjects | Phone Numbers |
| --------- | ---- | -------- | ------------- |
| 1         | Alex | CS, IT   | 1234, 5678    |

✅ After 1NF:
| StudentID | Name | Subject | PhoneNumber |
| --------- | ---- | ------- | ----------- |
| 1         | Alex | CS      | 1234        |
| 1         | Alex | IT      | 5678        |

🌟 Second Normal Form (2NF)
Precondition: Must already satisfy 1NF.

Rules:
👉 No partial dependency → every non-key attribute should depend on the whole primary key, not just a part of it.
👉 Applies only when the table has a composite primary key (more than one column as PK).

✅ Example (Before 2NF):
| StudentID | CourseID | StudentName | CourseName | Instructor |
➤ Composite key = (StudentID, CourseID)
➤ Problem: StudentName depends only on StudentID, not on CourseID.

✅ After 2NF:
➤ Students Table: (StudentID → StudentName)
➤ Courses Table: (CourseID → CourseName, Instructor)
➤ Enrollment Table: (StudentID, CourseID)

🌟 Third Normal Form (3NF)
Precondition: Must already satisfy 2NF.

Rules:
👉 No transitive dependency → non-key attributes should not depend on other non-key attributes.
👉 Every non-key column must depend only on the primary key.

✅ Example (Before 3NF):
| StudentID | Name | DeptID | DeptName | DeptHead |
➤ Problem: DeptName and DeptHead depend on DeptID, not directly on StudentID.

✅ After 3NF:
➤ Students Table: (StudentID → Name, DeptID)
➤ Departments Table: (DeptID → DeptName, DeptHead)

⚡ Tips:
Emphasize:
✔️ 1NF → Atomic values, no repeating groups.
✔️ 2NF → Remove partial dependency.
✔️ 3NF → Remove transitive dependency.

🧠 Common trap: Interviewers may ask if 2NF applies when there is no 
 composite key.
🔄 Answer: No, because partial dependency exists only with composite keys.

🧠 Working through normalization step-by-step helps ensure a well-structured database design.

✅ For Example:
(0) Unnormalized table (UNF)

OrderSheet (single table)
OrderID | OrderDate|CustomerName|CustomerEmail|CustomerAddress|BookISBN| BookTitle | BookAuthor  |UnitPrice  |Quantity|LineTotal|  PhoneNumbers (comma-separated)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-1    | SQL Basics| Ada Lovelace| 500       | 1      | 500     | Phones: "98765, 91234"
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-2    | DB Design | E. Codd     | 700       | 2      | 1400    | Phones: "98765, 91234"
102     |2025-08-02| Robert Ray | rob@y.com  | 42 Galaxy Way| 999-2    | DB Design | E. Codd     | 700       | 1      | 700     | Phones: "99887"

What’s wrong here:
➤ Multi-valued attribute: PhoneNumbers = "98765, 91234" (not atomic).
➤ Redundancy: customer & book details repeat across rows.
➤ Update anomalies: change John’s address → must update many rows.
➤ Insert/delete anomalies: can’t insert a new book without an order; deleting John’s order may “lose” the book’s master data.

🌟 First Normal Form (1NF)
Goal:
➤ Make every cell atomic, consistent types, define a key, and eliminate repeating groups.

Fixes we’ll do
➤ Remove comma-separated phones into a separate table.
➤ Keep a composite primary key (OrderID, BookISBN) in the order-lines so two books in one order are allowed.
➤ Keep other columns as-is for now.

1NF schema
OrderLines_1NF(
  OrderID,        -- part of PK
  BookISBN,       -- part of PK
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress,
  BookTitle,
  BookAuthor,
  UnitPrice,
  Quantity,
  LineTotal
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_1NF(
  CustomerEmail,  -- we’ll temporarily use email to link phones
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

⚡Why this is 1NF now
➤ No multi-valued fields; phones are atomic and stored as separate rows.
➤ A row is uniquely identified by (OrderID, BookISBN).
➤ Column types are consistent.

Still redundant: Customer info depends only on OrderID; book info depends only on BookISBN. That’s the 2NF problem.

🌟 Second Normal Form (2NF):
✅ Precondition: Table(s) are in 1NF.

❗Rule: No partial dependency—every non-key attribute must depend on the entire composite key (when a composite key exists).

In OrderLines_1NF, the PK is (OrderID, BookISBN):
➤ OrderDate, CustomerName, CustomerEmail, CustomerAddress depend only on OrderID (part of the key) → partial dependency.
➤ BookTitle, BookAuthor, UnitPrice depend only on BookISBN (part of the key) → partial dependency.
➤ Quantity, LineTotal depend on both → fine.

Decompose to remove partial dependencies

2NF schema
Orders_2NF(
  OrderID PK,
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress
)

Books_2NF(
  BookISBN K,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems_2NF(
  OrderID        -- part of PK, FK -> Orders_2NF(OrderID)
  BookISBN       -- part of PK, FK -> Books_2NF(BookISBN)
  Quantity,
  LineTotal,
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_2NF(
  CustomerEmail,
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

🔗 What we gained
➤ No attribute in OrderItems_2NF depends only on part of its composite key.
➤ Book and customer order headers are stored once—redundancy drops.

Still an issue for 3NF: In Orders_2NF, CustomerName/Email/Address are really properties of a Customer, not of an Order. We also still keep LineTotal, which is derivable (Quantity × UnitPrice). That creates a transitive/derived dependency risk.

🌟 Third Normal Form (3NF)
✅ Precondition: In 2NF.
❗ Rule: No transitive dependency—non-key attributes must not depend on other non-key attributes.

What’s transitive here?

If we introduce a stable CustomerID, then:
➤ Orders would have CustomerID (FK) and non-key attributes like CustomerName/Email/Address would depend on CustomerID, not directly on OrderID → transitive dependency in Orders_2NF.
➤ LineTotal depends on Quantity and UnitPrice (the latter is in Books). It’s derivable, and storing it risks inconsistency.

🔄 Decompose & clean

Final 3NF schema
Customers(
  CustomerID     PK,
  CustomerName,
  CustomerEmail  UNIQUE,
  CustomerAddress
)

CustomerPhones(
  CustomerID     FK -> Customers(CustomerID),
  PhoneNumber,
  PRIMARY KEY (CustomerID, PhoneNumber)
)

Orders(
  OrderID        PK,
  OrderDate,
  CustomerID     FK -> Customers(CustomerID)
)

Books(
  BookISBN       PK,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems(
  OrderID        FK -> Orders(OrderID),
  BookISBN       FK -> Books(BookISBN),
  Quantity,
  -- no LineTotal here (computed when needed)
  PRIMARY KEY (OrderID, BookISBN)
)
🔗 Why this is 3NF:
➤ In Orders, every non-key attribute (OrderDate, CustomerID) depends only on the key (OrderID), and nothing depends on another non-key attribute.
➤ Customer details live in Customers; phones in CustomerPhones with a clean 1-to-many.
➤ Book master data is in Books.
➤ OrderItems only has attributes that depend on the whole composite key (OrderID, BookISBN).
➤ Derived value LineTotal removed → no transitive/derived dependency.

Sample data (3NF)

📝 Customers
CustomerID | CustomerName | CustomerEmail | CustomerAddress
-----------------------------------------------------------
C001       | John Smith   | john@x.com    | 221B Baker St
C002       | Robert Ray   | rob@y.com     | 42 Galaxy Way

📝 CustomerPhones
CustomerID | PhoneNumber
------------------------
C001       | 98765
C001       | 91234
C002       | 99887

📝 Books
BookISBN | BookTitle     | BookAuthor   | UnitPrice
---------------------------------------------------
999-1    | SQL Basics    | Ada Lovelace | 500
999-2    | DB Design     | E. Codd      | 700

📝 Orders
OrderID | OrderDate   | CustomerID
-----------------------------------
101     | 2025-08-01  | C001
102     | 2025-08-02  | C002

📝 OrderItems
OrderID | BookISBN | Quantity
-----------------------------
101     | 999-1    | 1
101     | 999-2    | 2
102     | 999-2    | 1

🔄 Practical SQL (3NF):
Create tables
-- Master tables

CREATE TABLE Customers (
  CustomerID      VARCHAR(10) PRIMARY KEY,
  CustomerName    VARCHAR(100) NOT NULL,
  CustomerEmail   VARCHAR(150) UNIQUE NOT NULL,
  CustomerAddress VARCHAR(200) NOT NULL
);

CREATE TABLE CustomerPhones (
  CustomerID   VARCHAR(10) NOT NULL,
  PhoneNumber  VARCHAR(20) NOT NULL,
  PRIMARY KEY (CustomerID, PhoneNumber),
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE Books (
  BookISBN    VARCHAR(20) PRIMARY KEY,
  BookTitle   VARCHAR(150) NOT NULL,
  BookAuthor  VARCHAR(100) NOT NULL,
  UnitPrice   DECIMAL(10,2) NOT NULL
);

-- Transaction tables
CREATE TABLE Orders (
  OrderID     INT PRIMARY KEY,
  OrderDate   DATE NOT NULL,
  CustomerID  VARCHAR(10) NOT NULL,
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE OrderItems (
  OrderID    INT NOT NULL,
  BookISBN   VARCHAR(20) NOT NULL,
  Quantity   INT NOT NULL CHECK (Quantity > 0),
  PRIMARY KEY (OrderID, BookISBN),
  FOREIGN KEY (OrderID)  REFERENCES Orders(OrderID),
  FOREIGN KEY (BookISBN) REFERENCES Books(BookISBN)
);


⚡ Compute an order’s total (derived at query-time, no redundancy):
➤ SELECT
  oi.OrderID,
  SUM(oi.Quantity * b.UnitPrice) AS OrderTotal
FROM OrderItems oi
JOIN Books b ON b.BookISBN = oi.BookISBN
WHERE oi.OrderID = 101
GROUP BY oi.OrderID;

⚡ List line items with computed line totals:
➤ SELECT
  o.OrderID,
  o.OrderDate,
  c.CustomerName,
  b.BookTitle,
  oi.Quantity,
  (oi.Quantity * b.UnitPrice) AS LineTotal
FROM Orders o
JOIN Customers c   ON c.CustomerID = o.CustomerID
JOIN OrderItems oi ON oi.OrderID = o.OrderID
JOIN Books b       ON b.BookISBN = oi.BookISBN
WHERE o.OrderID = 101;

✅ Key takeaways (interview-friendly)
⚡ 1NF: Atomic values, no repeating groups; define a key.
⚡ 2NF: Remove partial dependencies from tables with composite keys (separate order header vs. book master vs. order items).
⚡ 3NF: Remove transitive dependencies (move customer details to Customers; drop derived LineTotal).

Result: minimal redundancy, better integrity; queries use joins to rebuild the full picture.

🔷 Spring Data JPA
Spring Data JPA is a Spring framework project built on top of JPA (Java Persistence API) that makes database access and persistence operations easier.

👉 In short:
➤ JPA = Specification (interfaces & annotations, no implementation).
➤ Hibernate = Implementation of JPA.
➤ Spring Data JPA = Abstraction layer that makes working with JPA implementations (like Hibernate) much easier.

🔹 Why Spring Data JPA?
Without it, you’d need to write a lot of boilerplate DAO code like this:

public class EmployeeRepository {
    @PersistenceContext
    private EntityManager em;

    public void save(Employee emp) {
        em.persist(emp);
    }

    public Employee findById(Long id) {
        return em.find(Employee.class, id);
    }
}

With Spring Data JPA, this becomes:
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
}
✅ Done. Spring auto-generates the implementation at runtime.

🌟 Key Features
🔄 Repository Abstractions
➤ Provides ready-made repository interfaces:
  🔗 CrudRepository<T, ID> → basic CRUD.
  🔗 JpaRepository<T, ID> → CRUD + pagination + sorting.
➤ No need to implement DAO manually.

🔄 Derived Query Methods
Spring parses method names and generates SQL automatically.

Example:
List<Employee> findByDepartment(String department);
List<Employee> findBySalaryGreaterThan(double salary);
👉 These automatically generate SELECT queries.

🔄 Custom Queries with JPQL / Native SQL
➤ Use @Query annotation for custom queries:
@Query("SELECT e FROM Employee e WHERE e.salary > :salary")
List<Employee> findHighEarners(@Param("salary") double salary);

➤ Native SQL also supported:
@Query(value = "SELECT * FROM employee WHERE department = :dept", nativeQuery = true)
List<Employee> findByDept(@Param("dept") String dept);

🔄 Pagination and Sorting
➤ Built-in support:
Page<Employee> findAll(Pageable pageable);
List<Employee> findAll(Sort sort);

🔄 Transaction Management
➤ Integrated with Spring’s @Transactional.
➤ Spring handles opening, committing, rolling back transactions automatically.

🔄 Auditing
➤ Track createdBy, createdDate, lastModifiedBy, lastModifiedDate with annotations:
@CreatedDate
private LocalDateTime createdAt;

⚡ How it Works Behind the Scenes
➤ You declare a repository interface (e.g., EmployeeRepository extends JpaRepository<Employee, Long>).
➤ At runtime, Spring Data JPA creates a proxy implementation of this interface.
➤ The proxy internally uses EntityManager (from JPA) → which is backed by Hibernate (default in Spring Boot).
➤ SQL queries are generated based on:
  🔗 Method name conventions (e.g., findByName).
  🔗 @Query annotations.
  🔗 Default CRUD methods from JpaRepository.

📌 Repository Layer in Spring Boot
➤ The Repository Layer in Spring Boot is the layer that interacts with the database.
➤ It provides predefined methods to perform CRUD (Create, Read, Update, Delete) operations without writing SQL queries.
➤ It is built on Spring Data JPA, which internally uses Hibernate (by default) for ORM.

⚡ How It Works
➤ Instead of writing your own DAO (Data Access Object) classes with JDBC/Hibernate queries,
you just create an interface that extends one of Spring Data JPA’s repository interfaces.
➤ Spring Boot automatically creates the implementation at runtime.

Example:
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
}
Here:
Employee → Entity class
Integer → Primary Key type

🔄 Common Utility Methods
Repository interfaces provide many ready-made methods, such as:

🔧 save(entity) → Insert or update entity in DB
🔧 findById(id) → Retrieve entity by primary key
🔧 findAll() → Get all records
🔧 delete(entity) → Delete a record
🔧 deleteById(id) → Delete by primary key
🔧 count() → Count total records

🔄 Custom Query Methods
You can also define custom finder methods just by following naming conventions.

Example:
List<Employee> findByName(String name);
List<Employee> findBySalaryGreaterThan(float salary);
👉 Spring Data JPA automatically generates queries for these methods.

🔄 Industry-level Use
➤ In enterprise applications, Repository Layer is where all database interaction is isolated.
➤ The Service Layer calls the Repository Layer, and repository handles DB operations.
➤ This ensures separation of concerns and clean architecture.  

📌 Dependency Injection (DI) in Spring Boot➤ 
➤ Dependency Injection (DI) is a design pattern where an object’s dependencies (other objects it needs to work) are provided (injected) by the Spring Framework instead of the class creating them manually.
➤ Spring Boot manages the creation, configuration, and lifecycle of these dependencies at runtime.

🔄 Analogy
👉 Think of building a house:
You need bricks, cement, wood.
Instead of making these materials yourself, you ask suppliers to provide them.

Similarly, your class does not create its required objects itself; Spring provides them automatically.

🔄 Why Use DI?
✅ Loose Coupling
➤ Classes do not depend on how objects are created, only on what they can do.
➤ Easier to swap implementations (e.g., change from MySQL DB to MongoDB without modifying business logic).

✅ Automatic Lifecycle Management
➤ Spring controls the object creation, initialization, and destruction.
➤ You don’t need to manually manage memory or cleanup.

🔄 Improved Testability
Since dependencies are injected, you can easily mock objects for unit testing.

🔄 Types of Dependency Injection in Spring Boot
📝 Constructor Injection ✅ (Most recommended in modern Spring Boot)

@Service
public class EmployeeService {
    private final EmployeeRepository employeeRepository;

    // Constructor Injection
    public EmployeeService(EmployeeRepository employeeRepository) {
        this.employeeRepository = employeeRepository;
    }
}

📝 Setter Injection
@Service
public class EmployeeService {
    private EmployeeRepository employeeRepository;

    @Autowired
    public void setEmployeeRepository(EmployeeRepository employeeRepository) {
        this.employeeRepository = employeeRepository;
    }
}

📝 Field Injection ❌ (Not recommended for large apps, but commonly seen in small projects)
@Service
public class EmployeeService {
    @Autowired
    private EmployeeRepository employeeRepository;
}

🔄 How DI Works in Spring Boot
➤ Spring Boot scans the project for classes annotated with @Component, @Service, @Repository, @Controller, etc.
➤ It creates objects (called Spring Beans) of these classes.
➤ Whenever another class requires these objects, Spring injects them automatically (instead of you writing new).

Example:
@RestController
public class EmployeeController {

    private final EmployeeService employeeService;

    // Constructor Injection
    public EmployeeController(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    @GetMapping("/employees")
    public List<Employee> getAllEmployees() {
        return employeeService.getEmployees();
    }
}

👉 Here:
➤ EmployeeController depends on EmployeeService.
➤ Spring Boot automatically injects an instance of EmployeeService.

🌱 Spring IoC (Inversion of Control)
➤ IoC (Inversion of Control) is the principle where the control of object creation and management is transferred from the developer to the Spring IoC Container.
➤ In simple words: You don’t control the objects, Spring does.

🔄 Spring IoC Container
➤ Core of the Spring Framework.
➤ Responsible for:
  🔗 Creating objects (beans)
  🔗 Configuring them
  🔗 Injecting dependencies (DI)
  🔗 Managing their lifecycle

🔄 How It Works
➤ You annotate/configure classes with @Component, @Service, @Repository, @Controller etc.
➤ Spring IoC Container scans the project, finds these beans, and creates objects automatically.
➤ Dependencies between beans are resolved using Dependency Injection (DI).

🔄 Advantages
➤ Promotes loose coupling (objects don’t create their dependencies).
➤ Makes applications modular and testable.
➤ Simplifies configuration and lifecycle management.

🔄 Analogy
👉 Think of a restaurant:
➤ You don’t cook yourself; you just order.
➤ The kitchen (IoC Container) manages all cooking, preparation, and delivery.
➤ Similarly, you just define what you need, and Spring IoC takes care of how it’s created and managed.

🌀 Spring Bean Lifecycle
📝 Lifecycle Stages
➤ Bean Creation
  🔗 Spring IoC creates the bean object.
  🔗 Example: using @Component or configuration class.

➤ Dependency Injection
Dependencies are injected (e.g., using @Autowired or constructor injection).

➤ Initialization (Optional Hooks)
If the bean implements InitializingBean or has @PostConstruct method → executed here.

➤ Execution (In Use)
The bean is ready to be used by the application.

➤ Destruction
  🔗 When the application context shuts down, Spring destroys the bean.
  🔗 Example: @PreDestroy method or DisposableBean interface.

✔️ Diagram (Flow)
Bean Instantiation 
       ↓
Dependencies Injection (@Autowired)
       ↓
Initialization (@PostConstruct, afterPropertiesSet)
       ↓
Bean is Ready (used by app)
       ↓
Destruction (@PreDestroy, destroy())

Example
@Component
public class MyBean implements InitializingBean, DisposableBean {

    @Override
    public void afterPropertiesSet() {
        System.out.println("Bean is initialized");
    }

    @Override
    public void destroy() {
        System.out.println("Bean is destroyed");
    }
}

✅ JUnit in Spring Boot (Unit Testing)
➤ JUnit is a testing framework used in Java to perform unit testing.
➤ In unit testing (white-box testing), we test individual pieces of code (methods, classes) rather than the whole application.
➤ Spring Boot projects by default include the JUnit library, so you don’t need to add it manually.

⚡ Important Annotations in JUnit
🔄 @Test
➤ Marks a method as a test case.
➤ JUnit will execute this method and report PASS / FAIL based on output or assertions.
➤ Multiple @Test methods can exist in one class, each runs independently.

🔄 @BeforeEach
➤ Runs before every @Test method.
➤ Usually used for setting up resources or initialization.

🔄 @AfterEach
➤ Runs after every @Test method.
➤ Used for cleanup activities (e.g., closing DB connections).

🔄 @BeforeAll
➤ Runs once before all tests in the class.
➤ Must be static.
➤ Used for global setup (e.g., starting an in-memory database).

🔄 @AfterAll
➤ Runs once after all tests in the class.
➤ Must be static.
➤ Used for global cleanup (e.g., stopping server, closing shared resources).

🖥️ Example Code
package com.demo1;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Demo1ApplicationTests {

    // This runs ONCE before any test method
    @BeforeAll
    public static void beforeAll() {
        System.out.println(">>> Before All - Runs only once before all tests");
    }

    // This runs BEFORE EACH test method
    @BeforeEach
    public void beforeTest() {
        System.out.println(">>> Before Each - Runs before every test case");
    }

    // Test case 1
    @Test
    void test1() {
        System.out.println(">>> Executing Test 1");
    }

    // Test case 2
    @Test
    void test2() {
        System.out.println(">>> Executing Test 2");
    }

    // This runs AFTER EACH test method
    @AfterEach
    public void afterTest() {
        System.out.println(">>> After Each - Runs after every test case");
    }

    // This runs ONCE after all test methods have executed
    @AfterAll
    public static void afterAll() {
        System.out.println(">>> After All - Runs only once after all tests");
    }
}

📌 Expected Execution Flow
When you run the test class, JUnit will call methods in the following order:

>>> Before All - Runs only once before all tests

>>> Before Each - Runs before every test case
>>> Executing Test 1
>>> After Each - Runs after every test case

>>> Before Each - Runs before every test case
>>> Executing Test 2
>>> After Each - Runs after every test case

>>> After All - Runs only once after all tests