ðŸ”· TreeSet
1. Definition & Characteristics
âž¤ TreeSet is a class in Java that implements:
1. NavigableSet â†’ extends SortedSet â†’ extends Set interface.
2. Internally uses a TreeMap (Red-Black Tree) for storage.

âž¤ Stores unique elements only (no duplicates).
âž¤ Maintains ascending sorted order by default.

âž¤ Null Handling:
1. Only one null allowed if the set is empty initially.
2. If comparator or natural ordering is used, inserting null after elements are present will throw NullPointerException.

2. Internal Implementation
âž¤ Backed by TreeMap:
1. Elements are stored as keys in a TreeMap.
2. Values are a constant dummy object.

âž¤ Self-balancing Red-Black Tree:
Guarantees O(log n) for insertion, removal, and search.

âž¤ Sorting:
Uses natural ordering (Comparable) or a provided Comparator.

3. Constructors
âž¤ TreeSet() â†’ Natural ordering of elements.
âž¤ TreeSet(Collection c) â†’ Creates a TreeSet containing elements of the collection.
âž¤ TreeSet(SortedSet s) â†’ Creates a TreeSet with the same ordering as the given SortedSet.
âž¤ TreeSet(Comparator comp) â†’ Orders elements using the provided comparator.

4. Time Complexity
| Operation         | Complexity |
| ----------------- | ---------- |
| Add element       | O(log n)   |
| Remove element    | O(log n)   |
| Search (contains) | O(log n)   |
| Traversal         | O(n)       |

5. Key Methods
âž¤ Insertion & Removal
1. add(E e) â€“ Adds element if not already present.
2. remove(Object o) â€“ Removes element if present.
3. clear() â€“ Removes all elements.

âž¤ Search & Retrieval
1. contains(Object o) â€“ Checks if element exists.
2. first() â€“ Returns the lowest element.
3. last() â€“ Returns the highest element.

âž¤ Navigation (from NavigableSet)
1. ceiling(E e) â€“ Returns smallest â‰¥ given element.
2. floor(E e) â€“ Returns largest â‰¤ given element.
3. higher(E e) â€“ Returns smallest > given element.
4. lower(E e) â€“ Returns largest < given element.

âž¤ View & Subsets
1. headSet(E toElement) â€“ Elements < toElement.
2. tailSet(E fromElement) â€“ Elements â‰¥ fromElement.
3. subSet(E fromElement, E toElement) â€“ Elements in range.

âž¤ Descending Order
descendingSet() â€“ Returns view in reverse order.

6. Ordering Rules
âž¤ Natural Ordering:
1. Elements must implement Comparable.
2. Example: String, Integer already implement it.

âž¤ Custom Ordering:
1. Pass a Comparator in constructor.
2. If elements are not comparable and no comparator is given â†’ ClassCastException.

7. Common Interview Traps
âž¤ NullPointerException:
Adding null after elements exist (due to comparison).

âž¤ ClassCastException:
Adding heterogeneous types without a comparator.

âž¤ No Duplicates:
Even if objects are different references, if compareTo() or comparator returns 0, element is considered duplicate.

âž¤ Fail-Fast Iterator:
Iterator throws ConcurrentModificationException if modified during iteration (except through iteratorâ€™s own remove).

8. Advantages
âž¤ Maintains sorted order automatically.
âž¤ Efficient logarithmic time complexity.
âž¤ Provides navigation methods (ceiling, floor, etc.).

9. Disadvantages
âž¤ Slower than HashSet for insertion/search (log n vs O(1) average).
âž¤ Requires elements to be comparable.
âž¤ More memory overhead than a hash-based set.

10. When to Use TreeSet
âž¤ When you need sorted unique elements.
âž¤ When you need range queries (subSet, headSet, tailSet).
âž¤ When ordering is important but fast lookup is still required.

âœ…Code Example
import java.util.*;

public class TreeSetAllMethods {
    public static void main(String[] args) {
        
        // 1. Creating TreeSet (Natural Ordering)
        TreeSet<Integer> ts = new TreeSet<>();
        
        // 2. Adding elements
        ts.add(50);
        ts.add(20);
        ts.add(40);
        ts.add(10);
        ts.add(30);
        System.out.println("Initial TreeSet (Sorted): " + ts); // [10, 20, 30, 40, 50]
        
        // 3. Adding duplicate element (Ignored)
        ts.add(20);
        System.out.println("After adding duplicate 20: " + ts); // No change
        
        // 4. Removing elements
        ts.remove(40);
        System.out.println("After removing 40: " + ts);
        
        // 5. Search operations
        System.out.println("Contains 30? " + ts.contains(30));
        System.out.println("Contains 100? " + ts.contains(100));
        
        // 6. Getting first & last element
        System.out.println("First Element: " + ts.first());
        System.out.println("Last Element: " + ts.last());
        
        // 7. Navigation methods
        System.out.println("Ceiling(25): " + ts.ceiling(25)); // >= 25 â†’ 30
        System.out.println("Floor(25): " + ts.floor(25));     // <= 25 â†’ 20
        System.out.println("Higher(30): " + ts.higher(30));   // > 30 â†’ 50
        System.out.println("Lower(30): " + ts.lower(30));     // < 30 â†’ 20
        
        // 8. HeadSet, TailSet, SubSet
        System.out.println("HeadSet(<30): " + ts.headSet(30));           // [10, 20]
        System.out.println("TailSet(>=30): " + ts.tailSet(30));          // [30, 50]
        System.out.println("SubSet(20 to 50): " + ts.subSet(20, 50));    // [20, 30]
        
        // 9. Descending order
        System.out.println("Descending Set: " + ts.descendingSet());
        
        // 10. Iterating (Ascending)
        System.out.print("Ascending Iteration: ");
        for (Integer num : ts) {
            System.out.print(num + " ");
        }
        System.out.println();
        
        // 11. Iterating (Descending)
        System.out.print("Descending Iteration: ");
        Iterator<Integer> descItr = ts.descendingIterator();
        while (descItr.hasNext()) {
            System.out.print(descItr.next() + " ");
        }
        System.out.println();
        
        // 12. Creating TreeSet with Custom Comparator (Reverse Order)
        TreeSet<Integer> customTS = new TreeSet<>(Comparator.reverseOrder());
        customTS.addAll(Arrays.asList(5, 15, 25, 35, 45));
        System.out.println("Custom Comparator TreeSet (Descending): " + customTS);
        
        // 13. Clearing TreeSet
        ts.clear();
        System.out.println("TreeSet after clear(): " + ts);
    }
}

ðŸ”„Additional Methods
1. addAll(Collection c)
âž¤ Adds all elements from another collection.
âž¤ Ignores duplicates automatically (TreeSet property).

2. containsAll(Collection c)
âž¤ Returns true if all elements of given collection exist in the TreeSet.

3. removeAll(Collection c)
âž¤ Removes every element from the TreeSet that is present in the given collection.

âœ…Code Example
import java.util.*;
public class TreeSetAddRemoveContainsAll {
    public static void main(String[] args) {

        // Creating first TreeSet
        TreeSet<Integer> ts1 = new TreeSet<>();
        ts1.add(10);
        ts1.add(20);
        ts1.add(30);
        System.out.println("TreeSet 1: " + ts1); // [10, 20, 30]

        // Creating second TreeSet
        TreeSet<Integer> ts2 = new TreeSet<>();
        ts2.add(30);
        ts2.add(40);
        ts2.add(50);
        System.out.println("TreeSet 2: " + ts2); // [30, 40, 50]

        // 1. addAll() â†’ Adds all elements of ts2 into ts1 (duplicates ignored)
        ts1.addAll(ts2);
        System.out.println("After addAll(ts2) in ts1: " + ts1); // [10, 20, 30, 40, 50]

        // 2. containsAll() â†’ Checks if ts1 contains all elements of ts2
        boolean allPresent = ts1.containsAll(ts2);
        System.out.println("ts1 contains all elements of ts2? " + allPresent); // true

        // 3. removeAll() â†’ Removes all elements of ts2 from ts1
        ts1.removeAll(ts2);
        System.out.println("After removeAll(ts2) from ts1: " + ts1); // [10, 20]
    }
}


