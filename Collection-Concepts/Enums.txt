🔷 Enums in Java 
Enum (short for enumeration) is a special data type in Java used to represent a fixed set of named constants.

Introduced in Java 5.

Syntax:
enum EnumName {
    CONSTANT1, CONSTANT2, CONSTANT3
}

🌟Characteristics
➤ Each constant in an enum is public, static, and final by default.
➤ Enum extends java.lang.Enum internally.
➤ Cannot extend another class because enums already extend Enum.
➤ Can implement interfaces.
➤ Can have fields, constructors, and methods.
➤ Enum constants are singleton objects.

3. When to Use
1. When you have a predefined set of related constants, such as:
   ➤ Days of the week (MONDAY, TUESDAY, …)
   ➤ States in a process (STARTED, IN_PROGRESS, COMPLETED)
   ➤ Severity levels (MINOR, MAJOR, CRITICAL)
2. Avoids "magic numbers" and string literals in code.

🌟 Issues Without Enums (Your Current Code Problems)
➤ Constants like MINOR=0, MAJOR=1 require manual mapping.
➤ Risk of passing invalid values (e.g., 5 for severity).
➤ Poor readability: You have to remember what 1 or 2 means.
➤ No type safety — any int can be passed to methods.
➤ Switching over raw numbers is error-prone.
➤ Difficult to maintain — adding/removing constants requires editing multiple locations.

🌟 Benefits of Using Enums
✅ Type Safety — Compiler ensures only valid enum constants are used.
✅ Readability — Constants have meaningful names.
✅ No invalid values — Cannot pass unrelated numbers/strings.
✅ Easy to maintain — Adding new constants is straightforward.
✅ Can store data & behavior — Enums can have fields, constructors, and methods.

❌ Code without Enums

public class Severity{
    final static int MINOR=0;
    final static int MAJOR=1;
    final static int CRITICAL=2;
}

public class Defect{
    public static int getDefectFixingTime( int severity){
        return switch(severity){
            case 0 -> 1;
            case 1->  3;
            case 2 -> 5;
            default -> thorw new IllegalArgumentException("Unexpected Value);
        }
    }
}

public class ReportDefect {
public static void main(String[] args) {
	int days=Defect.getDefectFixingTime(2);
	System.out.println(days);
}
}

✅ Rewritten Using Enums
enum Severity {
    MINOR(1), MAJOR(3), CRITICAL(5);

    private final int fixingDays;

    //by default private constructor
    Severity(int fixingDays) {
        this.fixingDays = fixingDays;
    }

    //getter method
    public int getFixingDays() {
        return fixingDays;
    }
}

class Defect {

    public static int getDefectFixingTime(Severity severity) {
        return severity.getFixingDays();
    }
}

public class ReportDefect {
    public static void main(String[] args) {
        int days = Defect.getDefectFixingTime(Severity.CRITICAL);
        System.out.println(days);
    }
}

🔄How This Works

1. enum Severity:
    ➤ Represents fixed constants MINOR, MAJOR, and CRITICAL.
    ➤ Each constant stores an extra value (number of days) using a field.
    ➤ Constructor assigns this value.
    ➤ Method getFixingDays() retrieves it.

Defect class:
    ➤ Accepts only Severity type — prevents invalid arguments.

ReportDefect class:
    ➤ Calls method with an enum constant.
    ➤ Output for Severity.CRITICAL → 5.

🌟Key Enum Features Used Here
➤ Parameterized Enums: Storing extra information (fixingDays).
➤ Type-Safe Method Parameters: Accepting Severity instead of int.

Built-in Enum Methods:
    ➤ values() → Returns all constants.
    ➤ valueOf(String name) → Returns constant by name.
    ➤ ordinal() → Returns index of constant (0-based).

Example:
for (Severity s : Severity.values()) {
    System.out.println(s + " takes " + s.getFixingDays() + " days");
}

🌟Enum Memory & Performance
➤ Each enum constant is a singleton instance created at class load time.
➤ Performance-friendly — Similar to using static final constants but safer and more maintainable.
➤ No extra overhead for typical usage.

🌟Tips
➤ Enums in Java are class-like, not just constants.
➤ They are more powerful than enums in languages like C/C++.
➤ Can override methods for individual constants.
➤ Cannot extend other classes but can implement interfaces.
➤ Best practice: Use enums instead of int constants for fixed sets of values.    

| Aspect             | Int Constants (final static)                                            Enums                                                                  |
| Readability        | Less clear — values appear as numbers, meaning must be remembered or checked in code | Very clear — values have meaningful names               |
| Type Safety        | None — any integer can be passed accidentally                       | Strong — only predefined enum constants can be used                      |
| Maintainability    | Difficult — changing values may break multiple places silently      | Easy — changes are localized, compiler helps catch errors                |
| Extensibility      | Limited — adding new constants requires careful changes everywhere  | Easy — just add new enum constants without affecting existing logic much |
| Error Prevention   | Low — invalid integers may go unnoticed until runtime               | High — compile-time validation prevents most mistakes                    |
| Debugging          | Hard — logs show numbers without context                            | Easy — logs show constant names directly                                 |
| Refactoring Safety | Risky — renaming or reordering constants may cause logical issues   | Safe — compiler enforces correct usage                                   |
| Performance        | Slightly better in raw speed (no object creation)                   | Negligible performance difference for most applications                  |
| Business Risk      | Higher — more prone to bugs due to wrong values                     | Lower — safer to maintain and extend                                     |
| Best Use Case      | When extreme performance or memory constraints demand               | When a fixed set of named values is needed                               |

🔗Code using Built-in methods of Enums
enum Severity {
    LOW,
    MEDIUM,
    HIGH,
    CRITICAL
}

public class EnumExample {
    public static void main(String[] args) {

        // values()
        System.out.println("All constants:");
        for (Severity s : Severity.values()) {
            System.out.println(s);
        }

        // valueOf()
        Severity sev = Severity.valueOf("HIGH");
        System.out.println("\nValueOf(\"HIGH\") = " + sev);

        // ordinal()
        System.out.println("\nOrdinal positions:");
        for (Severity s : Severity.values()) {
            System.out.println(s + " -> " + s.ordinal());
        }
    }
}

✅Output:
All constants:
LOW
MEDIUM
HIGH
CRITICAL

ValueOf("HIGH") = HIGH

Ordinal positions:
LOW -> 0
MEDIUM -> 1
HIGH -> 2
CRITICAL -> 3
