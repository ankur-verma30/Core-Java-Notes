🔷 What is Collections?
A collection is simly an Object that represents a group of objects, known as its elements.

🔷 What is Collection Framework?
It provides a set of iterfaces and classes that help in managing groups of objects.

🧠 Before the introduction of Collection Framework in JDK 1.2, Java used to rely on a variety of classes like Vector, Stack, Hashtable, and arrays to store and manipulate groups of objects.

❌Drawbacks or limitations
1. Inconsistency: Each class had a different way of managing collections, leading to confusion and a steep learning curve.

2. Lack of inter-operability: These classes were not designed to work together seamlessly.

3. No common Interface: There was no common interface for all these classes which meant you couldn't write generic algorithms that could operate on different types of collections.

To solve those problems, the Collection Framework was introduced in JDK 1.2.

🔄Features of Collection Framework:
✅ Unified architecture: A consistent set of interfaces for all collections.
✅ Inter-operability: Collections can be easily interchanged and manipulated.
✅ Reusability: Generic algorithms can be written that work with any collections.
✅Efficiency: The framework provides efficient algorithms for basic operations like searching, sorting, and manipulation.

🔷 Key Interfaces in Collection Framework:
1. Collection: The root interface for all other collection types.
2. List: An ordered collection that can contain duplicate elements.(e.g., ArrayList, LinkedList);
3. Set: A collection that cannot contain duplicate elements (e.g., HashSet, TreeSet);
4. Queue: A collection designed for holding elements prior to processing (e.g., PriorityQueue, LinkedList when used as a queue);
5. Deque: A double-ended queue that allows insertion and removal from both ends (e.g., ArrayDeque);
4. Map: An interface that represents a collection of key-value pairs. (e.g. HashMap, TreeMap);

🔷 Hierarchy of Collection Framework:
Iterable
└── Collection
    ├── List
    │   ├── ArrayList
    │   ├── LinkedList
    │   ├── Vector
    │   ├── Stack
    │   └── CopyOnWriteArrayList
    │
    ├── Set
    │   ├── HashSet
    │   ├── LinkedHashSet
    │   ├── TreeSet
    │   ├── EnumSet
    │   ├── ConcurrentSkipListSet
    │   ├── SortedSet
    │   └── CopyOnWriteArraySet
    │
    └── Queue
        ├── LinkedList
        ├── PriorityQueue
        ├── Deque
        │   ├── ArrayDeque
        │   |── LinkedList (also Deque)
        |   |── ConcurrentLinkedDeque
        ├── BlockingQueue
        │   ├── ArrayBlockingQueue
        │   ├── LinkedBlockingQueue
        │   ├── PriorityBlockingQueue
        │   ├── SynchronousQueue
        │   └── DelayQueue
        └── ConcurrentLinkedQueue

🔷 List Interface
A List is an ordered collection that can contain duplicate elements. It allows positional access and insertion of elements.

✅ Key Features of the List Interface:
➤ Ordered
➤ Index-Based access
➤ Allows duplicates

🌟 ArrayList
An ArrayList is a resizable array implementation of the List interface. 
Unlike arrays in Java, which have a fixed size, ArrayList can change its size dynamically as elements are added or removed.
This flexibility makes it a popular choice when the number of elements in a list isn't known in advance.

✅Code Implementation of ArrayList:
package collections;

import java.util.ArrayList;

public class ArrayListIntro {

	public static void main(String[] args) {
		ArrayList<Integer> arr = new ArrayList<>();
		// adding elements
		arr.add(1);
		arr.add(5);
		arr.add(80);
		System.out.println(arr.get(2));// accessing the elements
		System.out.println(arr.size());// accessing the size of the arrayList

		System.out.println("");

		// using pointer to iterate on ArrayList
		for (int i = 0; i < arr.size(); i++) {
			System.out.print(arr.get(i) + " ");
		}

		System.out.println("");

		// Iterating using for-each loop
		for (int x : arr) {
			System.out.print(x + " ");
		}
		
		System.out.println("");

		// check for existence of elements
		System.out.println(arr.contains(5));
	
        // removing elements
		//returns the element that is removed and also remove the element
		int element=arr.remove(0);
		System.out.println(element);
		
        //adding elements at specific index
        arr.add(2,50);
        system.out.println(arr); //[1, 5, 50, 80];

        // setting elements at specific index
        arr.set(2, 100);
		System.out.println(arr); // [1, 5, 100, 80]

        // clearing the ArrayList
        arr.clear();
        System.out.println(arr); // []
	}
}

🔷 Internal Working of ArrayList
➤ Unlike a regular array, which has a fixed size, an ArrayList can grow and shrink as elements are added or removed. 
➤ This dynamic resizing is achieved by creating a new array when the current array is full and copying the elements to the new array.
➤ Internally the ArrayList is implemented as an array of Object references. 
➤ When you add elements to an ArrayList, you're essentially storing these elements in this internal array.
➤ When you create an ArrayList, it has an initial capacity(default is 10). The capacity refers to the size of the internal array that holds the elements before needing to resize.

🔷 Adding elements
When we add an element to an ArrayList, the following steps occur:

1. Checking Capacity: Before adding the new element, ArrayList checks if there is enough space in the internal array(elementData). IF the array is full, it needs to be resized.

2. Resize if necessary: If the internal array is full, the ArrayList will create a new array with a larger capacity (usually 1.5 times the current capacity) and copy the existing elements from the old array to the new array.

3. Add the Element: The new element is added to the internal array at the appropriate index, and the size is incremented.

🔷 Resizing the Array
1. Initial Capacity: By default, the initial capacityis 10. This means the internal array can hold 10 elements before it needs to grow.

2. Growth Factor: When the internal array is full, a new array is created with a size 1.5 times the old array. This growth factor balances memory efficiency and resizing cost.

3. Copying Elements: When resizing occurs, all elements from the old array are copied to the new array, which is an O(n) operation, where n is the number of elements in the ArrayList.

🔷 Removing Elements
1. Check Bounds: The ArrayList  checks if the index is within the valid range (0 to size - 1).

2. Remove the Element: The element is removed, and all elements to the right of the removed element are shifted to the left to fill the gap.

3. Reduce Size: The size is decremented by 1.

✅Code Implementation:

ArrayList<Integer> arr = new ArrayList<>(1000);// creating an ArrayList with initial capacity of 1000
		// adding elements
		System.out.println(arr.size());// gives 0
		System.out.println(arr.get(0));// IndexOutOfBoundsException because no elements are present

//There is no method to print the capacity of an ArrayList directly.

🔷 Creating an ArrayList
✅Method 1. Default constructor, creates an empty ArrayList with an initial capacity of 10
		ArrayList<Integer> list=new ArrayList<>();

✅Method 2. List is an interface, ArrayList is a class that implements the List interface.
        List<Integer> list2=new ArrayList<>(); 
		
✅Method 3. Creating an ArrayList with a specified initial capacity
		ArrayList<Integer> listWithCapacity=new ArrayList<>(20);
		
✅Method 4. Creating an ArrayList from another collection
		List<String> anotherList=Arrays.asList("Apple","Banana");//fixed-size list adding and removing elements is not allowed only replacing is allowed
		ArrayList<String> listFromCollection=new ArrayList<>(anotherList);


🧠 Miscellaneous Ways of Creating ArrayList in Java

1. Normal ArrayList
List<String> list = new ArrayList<>();
System.out.println(list.getClass().getName());

✅Output: java.util.ArrayList

➤ This is the regular ArrayList implementation.
➤ Backed by a resizable array.
➤ Fully mutable: you can add, remove, and update elements.

2. Using Arrays.asList() with direct values
List<String> list1 = Arrays.asList("Monday", "Tuesday");
System.out.println(list1.getClass().getName());

✅Output: java.util.Arrays$ArrayList

➤ This is NOT java.util.ArrayList
➤ It is an inner static class of java.util.Arrays called Arrays$ArrayList.
➤ Characteristics:
    1. Fixed-size list (backed by the given array).
    2. You can modify elements (set()), but cannot add() or remove().
    3. Trying list1.add("Wednesday") will throw UnsupportedOperationException.

list1.set(1, "Friday");   // Works ✅
System.out.println(list1.get(1)); // Output: Friday

3. Using Arrays.asList() on an existing array
String[] array = {"Apple", "Banana", "Cherry"};
List<String> list2 = Arrays.asList(array);
System.out.println(list2.getClass().getName());

✅ Output: java.util.Arrays$ArrayList

➤ Same as above: backed by the array itself.
➤ Any changes in list2 are reflected in the original array (because they share memory).

list2.set(0, "Mango"); 
System.out.println(array[0]); // Output: Mango (array updated too!)

4. Using List.of() (Java 9+) // Unmodifiable list can't even replace the elements unlike list made from Arrays.asList()
List<Integer> list3 = List.of(1, 2, 3);
System.out.println(list3.getClass().getName());

✅ Output: java.util.ImmutableCollections$ListN

✅ Key Points
➤ new ArrayList<>() → java.util.ArrayList (fully dynamic, resizable).
➤ Arrays.asList() → java.util.Arrays$ArrayList (fixed-size, backed by array).
➤ With an existing array, modifications affect both list and array.
➤ Arrays$ArrayList is an inner class only meant as a lightweight adapter.

⚡ Quick Trap Question:
👉 What happens if you call list1.add("Wednesday") on an Arrays.asList() list?
✔️ Answer: Throws UnsupportedOperationException because the list is fixed-size.    

🔷 Adding all elements 
✅Method 1. In the list at the end
        List<Integer>arr=new ArrayList<>();
		arr.add(1);
		arr.add(2);
		arr.add(3);
		
		List<Integer>list1=List.of(4,5,6,7,8,9);
		//adding all the elements
		arr.addAll(list1);
		
		System.out.println(arr);//✅Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]

✅Method 2. In the list at specific index
         arr.addAll(2,list1);
         System.out.println(arr);//✅Output: [1, 2, 4, 5, 6, 7, 8, 9,3]        


🔷 Removing elements from ArrayList
✅Method 1. By index
        arr.remove(2);//removes the element at index 2
        System.out.println(arr);//✅Output: [1, 2, 5, 6, 7, 8, 9,3]

✅Method 2. By value
        arr.remove(Integer.valueOf(5));//removes the first occurrence of the value 5        

🔷 Converting List to Array
String [] array = arr.toArray(new String[0]);
👉 This creates a new array of the same type as the list and copies the elements into it.        
👉 We pass new String[0] to tell the compiler the type of the array we are passing as a argument (Convention).

🔷 Sorting the List
✅Method 1: Collections.sort(arr);
👉 This sorts the list in ascending order using the natural ordering of the elements.

✅Method 2: arr.sort(null);
👉 This sorts the list in ascending order using the natural ordering of 
the elements.
👉 null is defined here because no custom comparator is used

🔷 Time Complexity of Operations in List
➤ Accessing by index (get) is O(1).
➤ Adding an element is O(n) in the worst case when resizing occurs.
➤ Removing elements can be O(n) because it may involve shifting elements.
➤ Iteration is O(n).

🔷 Comparator
It is an interface that defines a method for comparing two objects of the same type.
It is used to sort objects in a custom order.

🔷 How to use Comparator
public class ArrayListIntro {

	public static void main(String[] args) {
		List<Integer>arr=new ArrayList<>();
		arr.add(1);
		arr.add(2);
		arr.add(3);
		
		List<Integer>list1=List.of(4,5,6,7,8,9);
		//adding all the elements
		arr.addAll(2,list1);
		
		arr.sort(new CustomComparator());
		System.out.println(arr); // Output: [9, 8, 7, 6, 5, 4, 3, 2, 1]
	}
}
class CustomComparator implements Comparator<Integer>{

	@Override
	public int compare(Integer o1, Integer o2) {
		return o2-o1;
	}
}
👉 If we do o1-o2, it will sort in ascending order

🔷 Using lambda expression
✅ Example 1: Sorting Lexicographically
		List<String>str=Arrays.asList("Apple", "Mango","Banana");
		str.sort((a,b)-> a.compareTo(b));
		//if gives negative then first will come
		System.out.println(str); // Output: [Apple, Banana, Mango]

✅ Example 2: Sorting by Length		
		List<String>str2=Arrays.asList("Apple", "Plum","Banana");
		str2.sort((a,b)-> a.length()-b.length());
		System.out.println(str2);// Output: [Plum, Apple, Banana]


🌟 LinkedList
A LinkedList is a doubly-linked list implementation of the List and Deque interfaces.
It allows for efficient insertion and removal of elements at both ends of the list.

✅Custom Made LinkedList Implementation
package collections;

public class LinkedListIntro {

	public static void main(String[] args) {
		Node node1=new Node();
		node1.value=10;
		node1.next=null;
		
		Node node2=new Node();
		node2.value=2;
		node2.next=null;
		node1.next=node2;
		
		Node temp=node1;
		while(temp!=null) {
			System.out.println(temp.value);
			temp=temp.next;
		}
	}
}

class Node{
	public int value;
	public Node next;
}

👉 A LinkedList is a linear data structure where each element is a seperate object called a node. Each node contains two parts:
1. Data: The value stored in the node.
2. Pointer/Reference: Two Pointers, one points to the next node(next) and the other pointing to the previous node(previous).

⚡ Performance Considerations
➤ LinkedList has different performance characteristics compared to ArrayList:

🔄Insertion and Deletion: LinkedList is better for frequent insertions and deletions in the middle of the list because it does not require shifting elements, as in ArrayList.

🔄 Random Access: LinkedList has slower random access(get(int index)) compared to ArrayList because it has to traverse the list from the beginning to reach the desired index.

🔄 Memory Overhead: LinkedList requires more memory than ArrayList because each node in a LinkedList requires extra memory to store references to the next and the previous node.

✅ Using LinkedList Collection Framework

package collections;

import java.util.LinkedList;

public class LinkedListIntro {

	public static void main(String[] args) {
		LinkedList<Integer>linkedlist=new LinkedList<>();
		✅Adding elements and getting elements
		linkedlist.add(1);//O(1)
		linkedlist.add(2);
		linkedlist.add(3);
		
		System.out.println(linkedlist);
		
		//getting the value at 0th index
		System.out.println(linkedlist.get(0)); //O(n)
		
		//adding the value at specific index
		linkedlist.add(2, 5); // O(1)
		
		//adding at the first of the linkedlist
		linkedlist.addFirst(0); // O(1)
		
		//adding at the last of the linkedlist
		linkedlist.addLast(10); // O(1)
		
		System.out.println(linkedlist);
		
		//getting the first element
		System.out.println(linkedlist.getFirst());
		//getting the last element
		System.out.println(linkedlist.getLast());

		✅Removing elements
		//removing element on specific index
		int removedElement=linkedlist.remove(0);
		System.out.println(removedElement);
		
		System.out.println(linkedlist);
		
		//removing the first element
		int removed=linkedlist.remove();
		System.out.println(removed);
		
		System.out.println(linkedlist);
		
		//removing first and last element
		int val1=linkedlist.removeFirst();
		int val2=linkedlist.removeLast();
		
		System.out.println(val1+" "+val2);
		System.out.println(linkedlist);
		
		//Java 8 feature
		boolean flag=linkedlist.removeIf(x->x%2!=0);// 5 is removed
		System.out.println(flag); //tells that removal has taken place or not
		
		System.out.println(linkedlist);
		
		LinkedList<String> animals=new LinkedList<>(Arrays.asList("Cat","Dog","Elephant"));
		LinkedList<String> animalsToRemove=new LinkedList<>(Arrays.asList("Dog"));
		
		boolean removedAnimals=animals.removeAll(animalsToRemove);
		System.out.println(removedAnimals);
		System.out.println(animals);// Dog is removed
	}
}

🌟 Vectors
➤ A Vector in Java is a part of the java.util package and is one of the legacy classes in Java that implements the List interface.
➤ It was introduced in JDK 1.0 before collection framework and is synchronized, making it thread-safe.
➤ Now it is a part of the collection framework.
➤ Howeever, due to its synchronization overhead, it's generally recommended to use other modern alternatives like ArrayList in single-threaded scenarios.
➤ Despite this, vectors is still useful in certain situations, particularly when thread safety is a concern.

🔷 Key Features of Vectors
🔄 Dynamic Array: Like ArrayList, vector is a dynamic array that grows automatically when more elements are added than its current capacity.

🔄Synchronized: All the methods in Vector are synchronized, which make it thread-safe. This means multiple thread can work on a Vector without the risk of corrupting the data. However, this can introduce performance overhead in single-threaded environments.

🔄 Legacy Class: Vector was part of Java's original release and is considered a legacy class. It's generally recommended to use ArrayList in single-threaded environments due to performance Considerations.

🔄 Resizing Mechanisms: When the current capacity of the vector is excedded, it doubles its size by default(or increases by a specific capacity increment if provided).

🔄 Random Access: Similary to arrays and ArrayList, Vector allows random access to elements, making it efficient for accessing elements using index.

🔷 Constructor of Vectors
👉 Vector(): Creates a vector with an initial capacity of 10.
👉 Vector(int initialCapacity): Creates a vector with specified initial capacity.
👉 Vector(int initialCapacity, int capacityIncrement): Creates a vector with an initial capacity and capacity increment(how much the vector should grow when its capacity is exceeded).
👉Vector(<Collections<? extends E>c): Creates a vector containing the elements of the specified collection.

✅Code Implementation of Vector
package collections;

import java.util.Vector;

public class VectorDemo {
	public static void main(String[] args) {
		Vector<Integer> vector = new Vector<>(3);

		// can check the initial capacity
		System.out.println(vector.capacity());

		vector.add(1);
		vector.add(1);
		vector.add(1);
		vector.add(1);

		// New capacity=initialCapacity+capacityIncrement;
		// By default capacityIncrement is initalValue it doubles the capacity
		System.out.println(vector.capacity());

	}
}

✅Methods of Vector
➤ add(E e): Add an element to the end of the vector.
➤ add(int index, E element): Insert an element at a specific index.
➤ get(int index): Retrieve an element at a specific index.
➤ set(int index, E element): Replace an element at a specific index.
➤ remove(int index): Remove an element at a specific index.		
➤ remove(Object o): Remove the first occurrence of the specified element.
➤ size(): Return the number of elements in the vector.
➤ isEmpty(): Check if the vector is empty.
➤ contains(Object o): Check if the vector contains a specific element.
➤ clear(): Remove all elements from the vector.

✅Code Implementation of Vector Methods
import java.util.Vector;

public class VectorDemo {
    public static void main(String[] args) {
        // Create a Vector of Strings
        Vector<String> vector = new Vector<>();

        // 1. add(E e) - add element at the end
        vector.add("Apple");
        vector.add("Banana");
        vector.add("Cherry");
        System.out.println("After add: " + vector);

        // 2. add(int index, E element) - insert at specific index
        vector.add(1, "Mango");
        System.out.println("After add at index 1: " + vector);

        // 3. get(int index) - retrieve element at index
        System.out.println("Element at index 2: " + vector.get(2));

        // 4. set(int index, E element) - replace element
        vector.set(2, "Orange");
        System.out.println("After set at index 2: " + vector);

        // 5. remove(int index) - remove element by index
        vector.remove(3); // removes element at index 3
        System.out.println("After remove at index 3: " + vector);

        // 6. remove(Object o) - remove by value
        vector.remove("Apple"); 
        System.out.println("After removing 'Apple': " + vector);

        // 7. size() - get number of elements
        System.out.println("Size of vector: " + vector.size());

        // 8. isEmpty() - check if empty
        System.out.println("Is vector empty? " + vector.isEmpty());

        // 9. contains(Object o) - check if element exists
        System.out.println("Contains 'Banana'? " + vector.contains("Banana"));
        System.out.println("Contains 'Apple'? " + vector.contains("Apple"));

        // 10. clear() - remove all elements
        vector.clear();
        System.out.println("After clear: " + vector);
        System.out.println("Is vector empty after clear? " + vector.isEmpty());
    }
}

✅Output of above code:
After add: [Apple, Banana, Cherry]
After add at index 1: [Apple, Mango, Banana, Cherry]
Element at index 2: Banana
After set at index 2: [Apple, Mango, Orange, Cherry]
After remove at index 3: [Apple, Mango, Orange]
After removing 'Apple': [Mango, Orange]
Size of vector: 2
Is vector empty? false
Contains 'Banana'? false
Contains 'Apple'? false
After clear: []
Is vector empty after clear? true

🔷 Synchronization and Performance
👉 Since vector methods are synchronized, it ensures that only one thread can access the vector at a time. This makes it thread-safe but cna introduce performance overhead in single-threaded environments because synchronization adds locking and unlocking costs.

👉 In moder Java applications, ArrayList is generally preferred over Vector when synchronization isn't required. For thread-safe collections, the CopyOnWriteArrayList or ConcurrentHashMap from the java.util.concurrent package are often recommended.

🌟 Stack
👉 Stack extends Vector, it is synchronized making it thread-safe.
👉 LIFO structure: Stack follows the Last-In-First-Out(LIFO) principle, where the last element added is the first one to be removed.
👉 Inheritance: Stack is a subclass of Vector, which means it inherits all the features of a dynamic array but is constrained by the stack's LIFO nature.


✅Code Implementation
📝Method 1
package collections;

import java.util.Stack;

public class StackDemo {

	public static void main(String[] args) {
		Stack<Integer> st = new Stack<>();

		// to add the elements in the stack
		st.push(1);
		st.push(2);
		st.push(3);
		st.push(4);
		st.push(5);

		// to remove the top element
		int removedElement = st.pop();
		System.out.println(removedElement);
		System.out.println(st);

		// to see what the top element
		System.out.println(st.peek());

		// to check whether the stack is empty or not
		System.out.println(st.isEmpty());

		// to check the size of the stack
		System.out.println(st.size());

		//to search the element
		//Gives the index from the top
		System.out.println(st);
//		3 is at the 2nd index from the top
		System.out.println(st.search(3));	
	}
}

📝Method 2:
package collections;

import java.util.LinkedList;
import java.util.Stack;

public class StackDemo {

	public static void main(String[] args) {
		LinkedList<Integer> linkedlist = new LinkedList<>();

		// adding element in the LIFO manner
		linkedlist.addLast(1);
		linkedlist.addLast(2);
		linkedlist.addLast(3);
		linkedlist.addLast(4);
		linkedlist.addLast(5);

		// removing elements
		linkedlist.removeLast();

		// peek at the top element
		linkedlist.getLast();

		// return boolean whether the linkedlist is empty or not
		linkedlist.isEmpty();
	}
}

🌟 CopyOnWriteArrayList
👉 Copy on Write means that whenever an element is added or removed from the ArrayList, a new copy is created. This ensures that the ArrayList remains thread-safe even if multiple threads are accessing it concurrently.

👉 Read Operations: Fast and direct, since they happen on a stable list without interference from modifications.
👉 Write Operations: A new copy of the list is created for every modification. 
👉 The reference to the list is then updated so that subsequent reads use this new list.
👉 Useful when read operations are more in comparison to write operations because on writing each time a new copy is created hence memory consumption take place.

❌ Problem with List and ArrayList
package collections;

import java.util.ArrayList;
import java.util.List;

public class CopyOnWriteArrayListDemo {

	public static void main(String[] args) {
List<String>copyArrayList=new ArrayList<>();
		copyArrayList.add("Milk");
		copyArrayList.add("Eggs");
		copyArrayList.add("Bread");
		copyArrayList.add("Meat");
		
		for(String item:copyArrayList) {
			System.out.println(item);
			if(item.equals("Eggs")) {
				copyArrayList.add("Butter");
				System.out.println("Added Butter while Reading");
			}
		}
		System.out.println("The new udpated Array List");
		System.out.println(copyArrayList);
	}
}

❌Output:
Milk
Eggs
Added Butter while Reading
Exception in thread "main" java.util.ConcurrentModificationException
	at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1096)
	at java.base/java.util.ArrayList$Itr.next(ArrayList.java:1050)
	at CollectionFramework/collections.CopyOnWriteArrayListDemo.main(CopyOnWriteArrayListDemo.java:15)

While Iterating we cannot modify the list, it will throw an exception.

✅ Using CopyOnWriteArrayList:
List<String>copyArrayList=new CopyOnWriteArrayList<>(); //using this we will get the

⚡Output:
Milk
Eggs
Added Butter while Reading
Bread
Meat
The new udpated Array List
[Milk, Eggs, Bread, Meat, Butter]

🔷 Maps in Java
In Java, a Map is an object that maps keys to values. It cannot contain duplicate keys, and each key can map to at most one value. Thik of it as a dictionary where you look up a word(key ) to find its defintion(value).

Map does not extends collection interface. It extends Map interface.

🌟 Key Characteristics of the Map Interface
➤ Key-Value Pair: Each entry in a Map consists of a key and a value.
➤ Unique Keys: No two entries can have the same key.
➤ One Value per key: Each key maps to a single value.
➤ Order: Some implementations maintain insertion order(LinkedHashMap), nature order(TreeMap), or no order(HashMap).

🌟 HashMap
✅ Code Snippet:
package collections;

import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<Integer, String> hs = new HashMap<>();
		hs.put(1, "Ankur");
		hs.put(2, "Deepak");
		hs.put(3, "Suraj");
		hs.put(4, "Harsh");
		System.out.println(hs);

		System.out.println(hs.get(3));
		// if not present gives null
		System.out.println(hs.get(5));

		if (hs.containsKey(2)) {
			System.out.println("Key is present in the map");
		} else {
			System.out.println("Key is not present in the map");
		}

		if (hs.containsValue("Ankur")) {
			System.out.println("Value is present");
		} else {
			System.out.println("Value is not present");
		}

		// iterating the map Method 1
		System.out.println("Iterating on the map by keySet Method");
		// Set<Integer> keys=hs.keySet();
		for (int i : hs.keySet()) {
			System.out.println(i + " -> " + hs.get(i));
		}

		// Method 2
		System.out.println("Iterating on the map using entrySet Method");
		Set<Entry<Integer, String>> entrySet = hs.entrySet();
		for (Entry<Integer, String> entry : entrySet) {
			System.out.println(entry.getKey() + " -> " + entry.getValue().toUpperCase());
		}

		//hs.remove(1); //removing element based on key
		boolean isRemoved=hs.remove(1, "Deepak"); //removing based on key and value
		System.out.println(isRemoved); //because no entry exist of that type

	}
}

❌Output:
{1=Ankur, 2=Deepak, 3=Suraj, 4=Harsh}
Deepak
null
Key is not present in the map
Value is present
Iterating on the map by keySet Method
1 -> Ankur
2 -> Deepak
3 -> Suraj
4 -> Harsh
Iterating on the map using entrySet Method
1 -> ANKUR
2 -> DEEPAK
3 -> SURAJ	
4 -> HARSH
false

🌟 Key Characteristics of HashMap
➤ Unordered: Does not maintain any order of its elements.
➤ Allows null keys and Values: Can have one null key and multiple null values.
➤ Not Synchhronized: Not thread-safe, requires external synchronization if used in a multi-threaded context.
➤ Performance: Offers constant time performance(O(1)) for basic operations like get and put, assuming the hash function disperses elements properly.

🔄 Internal Structure of HashMap
Basic components:
✔️ Key: The identifer used to retrieve a value.
✔️ Value:The data associated with the key.
✔️ Bucket: A place where key-value paris are stored. Think of buckets as cells in a list(array).
✔️ Hash function: Converts a key into an index(bucket location) for storage.
➤ A hash function is an algorithm that takes an input(or key) and returns a fixed-size string of bytes, typically a numerical value. The output is known as the hash code, hash value or simply hash. The primary purpose of a hash function is to map data of arbitrary size to a fixed-size value.

Characteristics of Hash Function:
✔️ Deterministic: Given the same input, the hash function always produces the same output.
✔️ Fixed Output size: The output of the hash function is a fixed-size string of bytes.
✔️ Efficient Computation: The hash function is fast to compute.

🧠 How Data is Stored in HashMap
⚡ Step 1: Hashing the Key: 
The key is passed through a hash function to generate a unique hash code(an integer number). This hash code helps determine where the key-value pair will be stored in the array(called a "bucket array").

⚡ Step 2: Calculating the Index:
The hash code is then used to calculate an index in the array(bucket location) using
int index= hashCode % array.length;
The index decides which bucket will hold the key-value pair.
✅ For example: If the array size is 16, the key's hash code will be divided by `16, and the remainder will be the index.

⚡ Step 3: Storing in the Bucket:
The key-value pair is stored in the bucket at the calculated index.
Each bucket can hold multiple key-value pairs.
(this is called a collision handling mechanism).

🧠 How HashMap Retrieves Data
When we call get(Key), the HashMap follows the following steps:
⚡ Hashing the key: Similar to insertion, the key is hashed using the same hash function to calculate its hash code.
⚡ Finding the index: The hash code is used to find the index of the bucket where the key-value pair is stored.
⚡ Searching in the Bucket: Once the correct bucket is found, it checks for the key in that bucket. If found, it returns the value associated with the key.	

🆚Handling Collisions
➤ Since different keys can generate the same index(called a collision)
HashMap uses a technique to handle this situation. Java's HashMap uses Linked List(or balanced Red-Black Tree(self balancing binary search tree) after Java 8) to resolve collisions.

➤ If multiple key-value paris map to the same bucket, they are stored i a linked list inside the bucket.
➤ This is called Separate Chaining.

➤ When a key-value pair is retrieved, the HashMap traverse the linked list to find the value associated with the key.

🔄 HashMap Resizing(Rehashing)
➤ HashMap has an internal array size, which is by default is 16.
When the number of elements(key-value pairs) grows and exceeds a certain load factor(default is 0.75), HashMap automatically resizes the array to hold more data. This process is called rehashing.

➤ The default size of the array is 16, so when more than 12 elements(16*0.75) are inserted, the HashMap will resize.

❗During rehashing
➤ The array size is doubled
➤ All existing entries are rehashed(i.e., their positions are recalculated)
and placed in the new array.
➤ This ensures the HashMap continues to work efficiently even after more data is added.

⚡Time Compplexity
➤ Average: O(1) for insertion, deletion, search.
➤ Worst case (all collisions in same bucket): O(logn) (but rare in practice).
But after Java 8, if there are too many elements in the bucket, HashMap switches to a balanced tree instead of a linked list to ensure better performance.
TREEFY_THRESHOLD = 8 for converting linked list to balanced tree.

❗Problem:
➤ When you create a custom class Person with fields like id and name, and put it into a HashMap, then:
➤ By default, Object's implementation of hashCode() and equals() is used.
➤ That implementation uses memory address → so two objects with the same values (id=1, name="Ankur") are considered different keys.

Example (Problem Case):
import java.util.*;

class Person {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class Main {
    public static void main(String[] args) {
        Map<Person, String> map = new HashMap<>();

        Person p1 = new Person(1, "Ankur");
        Person p2 = new Person(1, "Ankur");

        map.put(p1, "Developer");
        map.put(p2, "Manager");

        System.out.println("Map size: " + map.size());
        System.out.println(map);
    }
}
👉 Output:
Map size: 2

➤ Even though both objects have the same id and name, they are treated as different keys.

✅ Fix:
To fix this, override hashCode() and equals() in the Person class.
🔄 Correct Implementation:
import java.util.*;

class Person {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Override equals
    @Override
    public boolean equals(Object o) {
        if (this == o) return true; // same reference
        if (o == null || getClass() != o.getClass()) return false;

        Person person = (Person) o;
        return id == person.id && Objects.equals(name, person.name);
    }

    // Override hashCode
    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }

    @Override
    public String toString() {
        return "Person{id=" + id + ", name='" + name + "'}";
    }
}

public class Main {
    public static void main(String[] args) {
        Map<Person, String> map = new HashMap<>();

        Person p1 = new Person(1, "Ankur");
        Person p2 = new Person(1, "Ankur");

        map.put(p1, "Developer");
        map.put(p2, "Manager");

        System.out.println("Map size: " + map.size());
        System.out.println(map);
    }
}
👉 Output:
Map size: 1
{Person{id=1, name='Ankur'}=Manager}

➤ Now both objects are considered the same key because hashCode() is same and equals() says they are equal.
➤ The second put() overwrites the value (Manager replaces Developer).

✔️ Key Notes 
➤ Always override both equals() and hashCode() together (not just one).
➤ If you only override equals() but not hashCode(), HashMap may still treat them as different keys.
➤ Use Objects.hash() and Objects.equals() (Java 7+) to simplify.
➤ Consistency rule: if a.equals(b) == true, then a.hashCode() == b.hashCode() must also hold.

✅ Working of getOrDefault() Method:
package collections;

import java.util.HashMap;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<String, Integer> hashMap = new HashMap<>();
		hashMap.put("Ankur", 100);
		hashMap.put("Alice", 99);
		hashMap.put("Bob", 101);

		Integer res1 = hashMap.getOrDefault("Ankur", -1);
		if (res1 != -1) {
			System.out.println("Ankur is present in the map");
		} else {
			System.out.println("Ankur Not present");
		}

		Integer res2 = hashMap.getOrDefault("Sam", -1);
		if (res2 != -1) {
			System.out.println("Sam is present in the map");
		} else {
			System.out.println("Sam Not present");
		}

	}
}

✅Output:
Ankur is present in the map
Sam Not present

✅Method: putIfAbsent()
Example:
package collections;

import java.util.HashMap;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<String, Integer> hashMap = new HashMap<>();
		hashMap.put("Ankur", 100);
		hashMap.put("Alice", 99);
		hashMap.put("Bob", 101);

		hashMap.putIfAbsent("Ankur", 200);
		hashMap.putIfAbsent("Sam", 201);
		System.out.println(hashMap);
	}
}

✅Output:
{Ankur=200, Alice=99, Bob=101, Sam=201}

🔷 LinkedHashMap
package collections;

import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapDemo {

	public static void main(String[] args) {
		LinkedHashMap<String, Integer> linkedHashMap = new LinkedHashMap<>();
		linkedHashMap.put("Orange", 10);
		linkedHashMap.put("Apple", 20);
		linkedHashMap.put("Mango", 30);
		
		for(Map.Entry<String, Integer>entry:linkedHashMap.entrySet()) {
			System.out.println(entry.getKey()+" -> "+ entry.getValue());
		}
	}
}

📌 Constructor
LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)

➤ initialCapacity → number of buckets initially.
➤ loadFactor → controls resizing.
➤ accessOrder →
	✔️ false → maintains insertion order.
	✔️ true → maintains access order (order changes when an entry is accessed with get() or put()).

✅ Example 1: accessOrder = false (Insertion Order)
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Insertion order
        Map<Integer, String> map = new LinkedHashMap<>(16, 0.75f, false);

        map.put(1, "A");
        map.put(2, "B");
        map.put(3, "C");

        // Access element
        map.get(2); // does NOT change order

        System.out.println("Insertion Order: " + map);
    }
}
👉 Output:
Insertion Order: {1=A, 2=B, 3=C}
Even though we accessed key 2, the order remains insertion order.

✅ Example 2: accessOrder = true (Access Order)
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Access order
        Map<Integer, String> map = new LinkedHashMap<>(16, 0.75f, true);

        map.put(1, "A");
        map.put(2, "B");
        map.put(3, "C");

        // Access element
        map.get(2); // moves 2 to end
        map.get(1); // moves 1 to end

        System.out.println("Access Order: " + map);
    }
}
👉 Output:
Access Order: {3=C, 2=B, 1=A}

First inserted order: {1=A, 2=B, 3=C}
After map.get(2) → 2 moves to end → {1=A, 3=C, 2=B}
After map.get(1) → 1 moves to end → {3=C, 2=B, 1=A}

⚡Tip
✔️ accessOrder = true is often used to implement LRU Cache (Least Recently Used).
✔️ removeEldestEntry() method can be overridden to auto-remove the oldest entry.

LinkedHashMap is a combination of HashMap + Doubly Linked List.

✅ Constructor Method:
LinkedHashMap linkedHashMap= new LinkedHashMap(hashMap);

🔷WeakHashMap
➤ WeakHashMap<K,V> is a special implementation of Map where keys are stored as weak references.
➤ If a key is not strongly referenced elsewhere in the program, the GC (Garbage Collector) can reclaim it.
➤ Once GC collects the key, the corresponding entry is automatically removed from the map.

🔄 Use of WeakHashMap
➤ Commonly used for caches where you don’t want unused objects to prevent GC.
➤ If the key object is no longer in use anywhere else → its entry is automatically removed.

✅ Example
import java.util.WeakHashMap;

public class WeakHashMapDemo {

	public static void main(String[] args) {
		WeakHashMap<String, Image> imageCache = new WeakHashMap<>();
		imageCache.put(new String("img1"), new Image("Image 1"));
		imageCache.put(new String("img2"), new Image("Image 2"));
		imageCache.put(new String("img3"), new Image("Image 3"));
		System.out.println(imageCache);
		System.gc();
		simulation();
		System.out.println("Cache after running(some entries may be cleared): " + imageCache);
	}

	private static void simulation() {
		try {
			System.out.println("Simulating application running...");
			Thread.sleep(10000);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Image {
	private String name;

	public Image(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return name;
	}
}
✅Output:
{img1=Image 1, img2=Image 2, img3=Image 3}
Simulating application running...
Cache after running(some entries may be cleared): {}

🧠Explaination
👉WeakHashMap<String, Image> imageCache = new WeakHashMap<>();
Creates a WeakHashMap where:
	✔️ Key = String (weakly referenced)
	✔️ Value = Image object (normal strong reference)

👉imageCache.put(new String("img1"), new Image("Image 1"));
➤ Uses new String("img1") → ensures the key is not from String pool (important!).
➤ If we had used "img1" directly, it would come from the string pool (strongly referenced by JVM), and GC wouldn’t clear it.

👉System.gc();
Suggests JVM to run garbage collection (not guaranteed, but usually works in demos).

👉simulation();
Sleeps for 10 seconds → gives JVM time to clear weakly referenced keys.

👉 Class Image
➤ Just a wrapper with a name field.
➤ toString() overridden → so when map is printed, values show as "Image 1", "Image 2", etc.

👉 Output Explaination:
➤ The second print may show {} or partially cleared entries depending on GC.
➤ Because keys (new String("imgX")) are weakly referenced → once GC runs, they vanish.

⚡ Important Points
✔️ WeakHashMap removes entries automatically when keys are weakly referenced and GC runs.
🆚 Difference from HashMap:
➤ HashMap → keys are strongly referenced (never removed unless explicitly).
➤ WeakHashMap → keys are weak references (removed after GC if no strong reference exists).
✔️ Values (Image) are still strongly referenced, but without a strong key reference, they become unreachable.
✔️ Useful for memory-sensitive caching.

🧠 Trap Question
package collections;

import java.util.HashMap;
import java.util.Map;

public class IdentityHashMapDemo {

	public static void main(String[] args) {
		String key1 = new String("Key");
		String key2 = new String("Key");
		Map<String, Integer> map = new HashMap<>();
		map.put(key1, 1);
		map.put(key2, 2);
		System.out.println(map);
	}

}
✅ Output: {key=2};
🧠Explaination: Even though string is made through new keyword, that hashcode will not be generated based on the memory address, as string already has a function to calculate hashcode based on the value stored inside the string so both the values are same. 
Therefore, inside the map it will use the key1.equals(key2) and it will return true so it will return the value of key2 which is 2.

If we want output like {key=1, key=2} then we can use IdentityHashMap.

🔷IdentityHashMap
➤ IdentityHashMap is a special implementation of Map in Java where keys are compared using reference equality (==) instead of equals().
➤ It is part of java.util package.

🌟 Key Features
➤ Uses reference equality (==) for both key comparison and hashing.
➤ Allows null keys and null values.
➤ Performance is similar to HashMap.
➤ Not synchronized (like HashMap).
➤ It breaks the general contract of Map because two logically equal keys (according to .equals()) may not be treated as equal here.

🆚 Difference from HashMap
| Feature        | `HashMap`                     | `IdentityHashMap`                |
| -------------- | ----------------------------- | -------------------------------- |
| Key comparison | Uses `equals()`               | Uses `==` (reference equality)   |
| Hashing        | Uses `hashCode()` of key      | Uses `System.identityHashCode()` |
| Usage          | When logical equality matters | When reference identity matters  |

✅ Example 1:
import java.util.*;

public class IdentityHashMapDemo {
    public static void main(String[] args) {
        Map<String, String> map = new IdentityHashMap<>();

        String a = new String("hello");
        String b = new String("hello");

        map.put(a, "Value A");
        map.put(b, "Value B");

        System.out.println("Size: " + map.size());
        System.out.println(map);
    }
}

✅ Output:
Size: 2
{hello=Value A, hello=Value B}
👉 Even though a.equals(b) is true, IdentityHashMap treats them as different keys because a != b (different objects in memory).

🌟 Use Cases
✔️ When you need object identity instead of equality.
✔️ Caching frameworks (where reference equality is important).
✔️ Serialization/deserialization where temporary objects need unique tracking.
✔️ Graph processing (tracking visited nodes by identity).
✔️ Object pools.

✅ Example: What will happen if you put two equal String objects as keys?
package collections;

import java.util.IdentityHashMap;
import java.util.Map;

public class IdentityHashMapDemo {

	public static void main(String[] args) {
		String key1 = new String("Key");
		String key2 = new String("Key");
		Map<String, Integer> map = new IdentityHashMap<>();
		map.put(key1, 1);
		map.put(key2, 2);
		System.out.println(map);
	}
}
✅Output : {Key=2}

🔷 Comparable
➤ Belongs to java.lang package.
➤ Used to define the natural/default ordering of objects.
➤ A class implements Comparable to provide its own comparison logic.
➤ It has one method:
🔗 public int compareTo(T o):
Returns:
	✔️ 0 → equal
	✔️ <0 → current object < given object
	✔️ >0 → current object > given object

🔸 Example: Student sorting by age (natural order)
class Student implements Comparable<Student> {
    String name;
    int age;

    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Student s) {
        return this.age - s.age; // ascending order
    }
}

✅ Comparator (Interface)
➤ Belongs to java.util package.
➤ Used when we want to define multiple sorting strategies or sorting logic outside the class.
➤ It has two main methods Java 8 added comparing() and thenComparing() for chaining.:
	✔️ public int compare(T o1, T o2);
	✔️ public boolean equals(Object obj); // rarely overridden
➤ Can be used with lambda/method references for concise sorting.

🔸 Example: Sorting Student by name
import java.util.*;

class Student {
    String name;
    int age;
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class NameComparator implements Comparator<Student> {
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name);
    }
}
🔄 Usage: Collections.sort(list, new NameComparator());

🆚 Comparable vs Comparator — Differences
| Feature             | Comparable                              | Comparator                                          |
| ------------------- | --------------------------------------- | --------------------------------------------------- |
| Package             | `java.lang`                             | `java.util`                                         |
| Method              | `compareTo(Object o)`                   | `compare(Object o1, Object o2)`                     |
| Sorting logic       | Defined **inside the class**            | Defined **outside the class**                       |
| Natural Order       | Provides **default (natural)** ordering | Provides **custom/multiple** orderings              |
| Modifies class code | Yes (must implement inside class)       | No (separate comparator class or lambda)            |
| One vs Many         | One natural order only                  | Many possible comparators                           |
| Java 8 support      | No enhancements                         | Added `comparing()`, `thenComparing()` for chaining |

✅ Example with Both
import java.util.*;

class Student implements Comparable<Student> {
    String name;
    int age;
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Natural order: by age
    @Override
    public int compareTo(Student s) {
        return this.age - s.age;
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student("John", 25));
        list.add(new Student("Alice", 22));
        list.add(new Student("Bob", 30));

        // Using Comparable (natural order: by age)
        Collections.sort(list);
        System.out.println("Sorted by age: " + list);

        // Using Comparator (custom order: by name)
        Collections.sort(list, (s1, s2) -> s1.name.compareTo(s2.name));
        System.out.println("Sorted by name: " + list);
    }
}

🌟 Insights
➤ Comparable → "I have a natural order, built inside the class."
➤ Comparator → "I allow multiple sorting logics, outside the class."
➤ Common trick: “Can a class implement both?” → ✅ Yes, a class can have a natural order (Comparable) and also be sorted by different comparators when needed.

🔷 SortedMap